<!DOCTYPE html><html class="article-header-style-default"><head><title>模板库 - NekoMio&#39;s Blog</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="description" content="算法 (AG) 网络流 (NF) 网络流线性规划 上下界网络流 最小割 费用流   Edmond-Karp (EK) Capacity Scaling Dinic&amp;SAP HLPP     差分约束 (DC) 通用线性规划 (LP) 单纯形算法   分数规划 (FP) 贪心 (GE) 分治 (DAC) 序列分治 CDQ&amp;整体二分&amp;线段树分治  快速排序 快速选择 Medi"><meta property="og:type" content="article"><meta property="og:title" content="模板库"><meta property="og:url" content="https://www.nekomio.com/2019/07/31/templates/index.html"><meta property="og:site_name" content="NekoMio&#39;s Blog"><meta property="og:description" content="算法 (AG) 网络流 (NF) 网络流线性规划 上下界网络流 最小割 费用流   Edmond-Karp (EK) Capacity Scaling Dinic&amp;SAP HLPP     差分约束 (DC) 通用线性规划 (LP) 单纯形算法   分数规划 (FP) 贪心 (GE) 分治 (DAC) 序列分治 CDQ&amp;整体二分&amp;线段树分治  快速排序 快速选择 Medi"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-07-31T03:04:10.000Z"><meta property="article:modified_time" content="2023-09-26T15:54:26.227Z"><meta property="article:author" content="NekoMio"><meta name="twitter:card" content="summary"><meta name="theme-color" content="#5e72e4"><meta name="theme-color-rgb" content="94,114,228"><meta name="theme-color-origin" content="#5e72e4"><meta name="argon-enable-custom-theme-color" content="true"><meta name="theme-card-radius" content="4"><meta name="theme-version" content="1.0.3"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/assets/argon_css_merged.css"><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="//fonts.loli.net/css?family=Open+Sans:300,400,600,700|Noto+Serif+SC:300,600&display=swap.css"><script src="/assets/argon_js_merged.js"></script><script src="/assets/js/argon.min.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/waline/2.15.5/waline.css"><script src="//cdn.bootcdn.net/ajax/libs/waline/2.15.5/waline.js"></script><script>var argonConfig={language:"zh_CN",zoomify:{duration:200,easing:"cubic-bezier(0.4,0,0,1)",scale:.9},pangu:"true",lazyload:{threshold:800,effect:"fadeIn"},disable_pjax:!1,headroom:!1,comment:!0,waline:null}</script><script>var darkmodeMediaQuery,darkmodeAutoSwitch="system";function setDarkmode(e){1==e?$("html").addClass("darkmode"):$("html").removeClass("darkmode"),$(window).trigger("scroll")}function toggleDarkmode(){$("html").hasClass("darkmode")?(setDarkmode(!1),sessionStorage.setItem("Argon_Enable_Dark_Mode","false")):(setDarkmode(!0),sessionStorage.setItem("Argon_Enable_Dark_Mode","true"))}function toggleDarkmodeByPrefersColorScheme(e){"false"!=sessionStorage.getItem("Argon_Enable_Dark_Mode")&&"true"!=sessionStorage.getItem("Argon_Enable_Dark_Mode")&&(e.matches?setDarkmode(!0):setDarkmode(!1))}function toggleDarkmodeByTime(){var e;"false"!=sessionStorage.getItem("Argon_Enable_Dark_Mode")&&"true"!=sessionStorage.getItem("Argon_Enable_Dark_Mode")&&setDarkmode((e=(new Date).getHours())<7||22<=e)}function toggleAmoledDarkMode(){$("html").toggleClass("amoled-dark"),$("html").hasClass("amoled-dark")?localStorage.setItem("Argon_Enable_Amoled_Dark_Mode","true"):localStorage.setItem("Argon_Enable_Amoled_Dark_Mode","false")}"true"==sessionStorage.getItem("Argon_Enable_Dark_Mode")&&setDarkmode(!0),"system"==darkmodeAutoSwitch&&((darkmodeMediaQuery=window.matchMedia("(prefers-color-scheme: dark)")).addListener(toggleDarkmodeByPrefersColorScheme),toggleDarkmodeByPrefersColorScheme(darkmodeMediaQuery)),"time"==darkmodeAutoSwitch&&toggleDarkmodeByTime(),"alwayson"==darkmodeAutoSwitch&&setDarkmode(!0),"true"==localStorage.getItem("Argon_Enable_Amoled_Dark_Mode")?$("html").addClass("amoled-dark"):"false"==localStorage.getItem("Argon_Enable_Amoled_Dark_Mode")&&$("html").removeClass("amoled-dark")</script><script>-1!==navigator.userAgent.indexOf("Safari")&&-1===navigator.userAgent.indexOf("Chrome")&&$("html").addClass("using-safari")</script><script src="/assets/vendor/smoothscroll/smoothscroll1.js"></script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/rss2.xml" title="NekoMio's Blog" type="application/rss+xml"></head><style id="themecolor_css">:root{--themecolor:#5e72e4;--themecolor-dark0:#5368E2;--themecolor-dark:#485FE0;--themecolor-dark2:#324CDD;--themecolor-dark3:#233DD2;--themecolor-light:#8A98EB;--themecolor-rgbstr:94,114,228;--themecolor-gradient:linear-gradient(150deg,var(--themecolor-light) 15%, var(--themecolor) 70%, var(--themecolor-dark0) 94%)}</style><style id="theme_cardradius_css">:root{--card-radius:4px}</style><body><div id="toolbar"><header class="header-global"><nav id="navbar-main" class="navbar navbar-main navbar-expand-lg navbar-transparent navbar-light bg-primary headroom--not-bottom headroom--not-top headroom--pinned"><div class="container"><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar_global" aria-controls="navbar_global" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button> <a class="navbar-brand" href="/">NekoMio&#39;s Blog</a><div class="navbar-collapse collapse" id="navbar_global"><div class="navbar-collapse-header"><div class="row"><div class="col-6 collapse-brand"></div><div class="col-6 collapse-close"><button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar_global" aria-controls="navbar_global" aria-expanded="false" aria-label="Toggle navigation"><span></span> <span></span></button></div></div></div><ul id="navbar_search_btn_mobile" class="navbar-nav align-items-lg-center ml-lg-auto"><li class="nav-item" data-toggle="modal" data-target="#argon_search_modal" style="padding-left:5px"><a class="nav-link nav-link-icon"><i class="fa fa-search"></i> <span class="nav-link-inner--text d-lg-none">搜索</span></a></li></ul><ul class="navbar-nav navbar-nav-hover align-items-lg-center"><li class="nav-item"><a href="/" class="nav-link"><i class="ni ni-book-bookmark d-lg-none"></i> <span class="nav-link-inner--text">首页</span></a></li><li class="nav-item"><a href="/archives" class="nav-link"><i class="ni ni-book-bookmark d-lg-none"></i> <span class="nav-link-inner--text">归档</span></a></li></ul><ul class="navbar-nav align-items-lg-center ml-lg-auto"><li class="nav-item" data-toggle="modal" data-target="#argon_search_modal" id="navbar_search_btn_pc"><a class="nav-link nav-link-icon"><i class="fa fa-search"></i> <span class="nav-link-inner--text d-lg-none">搜索</span></a></li></ul></div><div id="navbar_menu_mask" data-toggle="collapse" data-target="#navbar_global"></div></div></nav></header></div><div class="modal fade" id="argon_search_modal" tabindex="-1" role="dialog" aria-labelledby="" aria-hidden="true"><div class="modal-dialog modal-dialog-centered modal-lg" role="document"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">搜索</h5><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body"><div class="form-group mb-3"><div class="input-group input-group-alternative"><div class="input-group-prepend"><span class="input-group-text"><i class="fa fa-search"></i></span></div><input id="local-search-input" class="form-control" placeholder="搜索什么..." type="text" autocomplete="off" data-search.path="search.xml" data-config.root="/"></div><div id="local-search-result"></div></div></div></div></div></div><section id="banner" class="banner section section-lg section-shaped"><div class="shape shape-style-1 shape-primary"><span></span> <span></span> <span></span> <span></span> <span></span> <span></span> <span></span> <span></span> <span></span></div><div id="banner_container" class="banner-container container text-center"><div class="banner-title text-white"><span class="banner-title-inner">NekoMio&#39;s Blog</span></div></div><style>section.banner{background-image:url(/assets/img/banner.jpg)!important}</style></section><style>#content:before{content:'';display:block;position:fixed;left:0;right:0;top:0;bottom:0;z-index:-2;background:url(/assets/img/banner.jpg);background-position:center;background-size:cover;background-repeat:no-repeat;opacity:1;transition:opacity .5s ease}html.darkmode #content:before{filter:brightness(.65)}#content:after{content:'';display:block;position:fixed;left:0;right:0;top:0;bottom:0;z-index:-2;background:url(/assets/img/banner.jpg);background-position:center;background-size:cover;background-repeat:no-repeat;opacity:0;transition:opacity .5s ease}html.darkmode #content:after{opacity:1}html.darkmode #content:before{opacity:0}#banner,#banner .shape{background:0 0!important}</style><div id="float_action_buttons" class="float-action-buttons fabtns-unloaded"><button id="fabtn_toggle_sides" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-hidden="true" tooltip-move-to-left="移至左侧" tooltip-move-to-right="移至右侧"><span class="btn-inner--icon fabtn-show-on-right"><i class="fa fa-caret-left"></i></span> <span class="btn-inner--icon fabtn-show-on-left"><i class="fa fa-caret-right"></i></span></button> <button id="fabtn_back_to_top" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-label="Back To Top" tooltip="回到顶部"><span class="btn-inner--icon"><i class="fa fa-angle-up"></i></span></button> <button id="fabtn_go_to_comment" class="btn btn-icon btn-neutral fabtn shadow-sm d-none" type="button" aria-label="Comment" tooltip="评论"><span class="btn-inner--icon"><i class="fa fa-comment-o"></i></span></button> <button id="fabtn_toggle_darkmode" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-label="Toggle Darkmode" tooltip-darkmode="夜间模式" tooltip-blackmode="暗黑模式" tooltip-lightmode="日间模式"><span class="btn-inner--icon"><i class="fa fa-moon-o"></i><i class="fa fa-lightbulb-o"></i></span></button> <button id="fabtn_toggle_blog_settings_popup" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-label="Open Blog Settings Menu" tooltip="设置"><span class="btn-inner--icon"><i class="fa fa-cog"></i></span></button><div id="fabtn_blog_settings_popup" class="card shadow-sm" style="opacity:0" aria-hidden="true"><div id="close_blog_settings"><i class="fa fa-close"></i></div><div class="blog-setting-item mt-3"><div style="transform:translateY(-4px)"><div id="blog_setting_toggle_darkmode_and_amoledarkmode" tooltip-switch-to-darkmode="切换到夜间模式" tooltip-switch-to-blackmode="切换到暗黑模式"><span>夜间模式</span><span>暗黑模式</span></div></div><div style="flex:1"></div><label id="blog_setting_darkmode_switch" class="custom-toggle"><span class="custom-toggle-slider rounded-circle"></span></label></div><div class="blog-setting-item mt-3"><div style="flex:1">字体</div><div><button id="blog_setting_font_sans_serif" type="button" class="blog-setting-font btn btn-outline-primary blog-setting-selector-left">Sans Serif</button><button id="blog_setting_font_serif" type="button" class="blog-setting-font btn btn-outline-primary blog-setting-selector-right">Serif</button></div></div><div class="blog-setting-item mt-3"><div style="flex:1">阴影</div><div><button id="blog_setting_shadow_small" type="button" class="blog-setting-shadow btn btn-outline-primary blog-setting-selector-left">浅阴影</button><button id="blog_setting_shadow_big" type="button" class="blog-setting-shadow btn btn-outline-primary blog-setting-selector-right">深阴影</button></div></div><div class="blog-setting-item mt-3 mb-3"><div style="flex:1">滤镜</div><div id="blog_setting_filters" class="ml-3"><button id="blog_setting_filter_off" type="button" class="blog-setting-filter-btn ml-0" filter-name="off">关闭</button> <button id="blog_setting_filter_sunset" type="button" class="blog-setting-filter-btn" filter-name="sunset">日落</button> <button id="blog_setting_filter_darkness" type="button" class="blog-setting-filter-btn" filter-name="darkness">暗化</button> <button id="blog_setting_filter_grayscale" type="button" class="blog-setting-filter-btn" filter-name="grayscale">灰度</button></div></div><div class="blog-setting-item mb-3"><div id="blog_setting_card_radius_to_default" style="cursor:pointer" tooltip="恢复默认">圆角</div><div style="flex:1;margin-left:20px;margin-right:8px;transform:translateY(2px)"><div id="blog_setting_card_radius"></div></div></div><div class="blog-setting-item mt-1 mb-3"><div style="flex:1">主题色</div><div id="theme-color-picker" class="ml-3"></div></div></div><button id="fabtn_open_sidebar" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-label="Open Sidebar Menu" tooltip="菜单"><span class="btn-inner--icon"><i class="fa fa-bars"></i></span></button> <button id="fabtn_reading_progress" class="btn btn-icon btn-neutral fabtn shadow-sm" type="button" aria-hidden="true" tooltip="阅读进度"><div id="fabtn_reading_progress_bar" style="width:0%"></div><span id="fabtn_reading_progress_details">0%</span></button></div><div id="content" class="site-content"><script async src="https://www.googletagmanager.com/gtag/js?id=G-T9TWLDVQ6L"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-T9TWLDVQ6L")</script><div class="page-information-card-container"></div><div id="sidebar_mask"></div><aside id="leftbar" class="leftbar widget-area" role="complementary"><div id="leftbar_part1" class="widget widget_search card bg-white shadow-sm border-0"><div class="leftbar-banner card-body"><span class="leftbar-banner-title text-white">NekoMio&#39;s Blog</span> <span class="leftbar-banner-subtitle text-white"><span class="hitokoto"></span></span></div><ul id="leftbar_part1_menu" class="leftbar-menu"><li class="leftbar-menu-item"><a href="/">首页</a></li><li class="leftbar-menu-item"><a href="/archives">归档</a></li></ul><div class="card-body text-center leftbar-search-button"><button id="leftbar_search" class="btn btn-secondary btn-lg active btn-sm btn-block border-0" role="button" data-toggle="modal" data-target="#argon_search_modal"><i class="menu-item-icon fa fa-search mr-0"></i> 搜索</button></div></div><div id="leftbar_part2" class="widget widget_search card bg-white shadow-sm border-0"><div id="leftbar_part2_inner" class="card-body"><div class="nav-wrapper" style="padding-top:5px"><ul class="nav nav-pills nav-fill" role="tablist"><li class="nav-item sidebar-tab-switcher"><a class="active show" id="leftbar_tab_catalog_btn" data-toggle="tab" href="#leftbar_tab_catalog" role="tab" aria-controls="leftbar_tab_catalog" no-pjax>文章目录</a></li><li class="nav-item sidebar-tab-switcher"><a id="leftbar_tab_overview_btn" data-toggle="tab" href="#leftbar_tab_overview" role="tab" aria-controls="leftbar_tab_overview" no-pjax>站点概览</a></li></ul></div><div><div class="tab-content" style="padding:10px 10px 0 10px"><div class="tab-pane fade active show" id="leftbar_tab_catalog" role="tabpanel" aria-labelledby="leftbar_tab_catalog_btn"><div id="leftbar_catalog"></div><script>$(function(){$(document).headIndex({articleWrapSelector:"#post_content",indexBoxSelector:"#leftbar_catalog",subItemBoxClass:"index-subItem-box",itemClass:"index-item",linkClass:"index-link",offset:80})})</script><style>#leftbar_catalog ul{counter-reset:blog_catalog_number}#leftbar_catalog li.index-item>a:before{content:counters(blog_catalog_number, '.') " ";counter-increment:blog_catalog_number}</style></div><div class="tab-pane fade text-center" id="leftbar_tab_overview" role="tabpanel" aria-labelledby="leftbar_tab_overview_btn"><img id="leftbar_overview_author_image" src="/null.webp" class="img-fluid rounded-circle shadow-sm" style="width:100px" alt="avatar"><h6 id="leftbar_overview_author_name">NekoMio</h6><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">159</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a data-toggle="modal" data-target="#blog_categories"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a data-toggle="modal" data-target="#blog_tags"><span class="site-state-item-count">68</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="site-author-links"><div class="site-author-links-item"><a href="https://github.com/NekoMio" rel="noopener" target="_blank">Github</a></div><div class="site-author-links-item"><a href="https://space.bilibili.com/11558109" rel="noopener" target="_blank">BiliBili</a></div></div><div class="site-friend-links"><div class="site-friend-links-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="site-friend-links-ul"><li class="site-friend-links-item"><a href="https://al0ha0e.github.io" rel="noopener" target="_blank">Al0ha0e</a></li><li class="site-friend-links-item"><a href="http://icontofig.leanote.com/" rel="noopener" target="_blank">icontofig</a></li><li class="site-friend-links-item"><a href="https://128bit.top" rel="noopener" target="_blank">Duxeran</a></li><li class="site-friend-links-item"><a href="https://zhuohao.me" rel="noopener" target="_blank">YZH</a></li></ul></div></div></div></div></div></div></aside><div class="modal fade" id="blog_categories" tabindex="-1" role="dialog" aria-labelledby="" aria-hidden="true"><div class="modal-dialog modal-dialog-centered"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">分类</h5><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body"><a class="badge badge-secondary tag" href="/categories/%E5%9B%BE%E5%BA%93/Test/" rel="tag">Test <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/categories/%E5%9B%BE%E5%BA%93/" rel="tag">图库 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/categories/%E7%94%9F%E6%B4%BB/" rel="tag">生活 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">知识点 <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/categories/%E7%AC%94%E8%AE%B0/" rel="tag">笔记 <span class="tag-num">10</span></a><a class="badge badge-secondary tag" href="/categories/%E9%9A%8F%E7%AC%94/" rel="tag">随笔 <span class="tag-num">7</span></a><a class="badge badge-secondary tag" href="/categories/%E9%A2%98%E8%A7%A3/" rel="tag">题解 <span class="tag-num">137</span></a></div></div></div></div><div class="modal fade" id="blog_tags" tabindex="-1" role="dialog" aria-labelledby="" aria-hidden="true"><div class="modal-dialog modal-dialog-centered"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">标签</h5><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body"><a class="badge badge-secondary tag" href="/tags/2-SAT/" rel="tag">2-SAT <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">AC自动机 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/BFS/" rel="tag">BFS <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/CDQ/" rel="tag">CDQ <span class="tag-num">4</span></a><a class="badge badge-secondary tag" href="/tags/DP/" rel="tag">DP <span class="tag-num">13</span></a><a class="badge badge-secondary tag" href="/tags/FFT/" rel="tag">FFT <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/FFT-NTT/" rel="tag">FFT&NTT <span class="tag-num">7</span></a><a class="badge badge-secondary tag" href="/tags/FWT/" rel="tag">FWT <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/KD-Tree/" rel="tag">KD-Tree <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/KMP/" rel="tag">KMP <span class="tag-num">3</span></a><a class="badge badge-secondary tag" href="/tags/LCA/" rel="tag">LCA <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/SPFA/" rel="tag">SPFA <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/STL/" rel="tag">STL <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/Tarjan/" rel="tag">Tarjan <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/Treap/" rel="tag">Treap <span class="tag-num">4</span></a><a class="badge badge-secondary tag" href="/tags/Trie/" rel="tag">Trie <span class="tag-num">4</span></a><a class="badge badge-secondary tag" href="/tags/dfs/" rel="tag">dfs <span class="tag-num">5</span></a><a class="badge badge-secondary tag" href="/tags/fail%E6%A0%91/" rel="tag">fail树 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/hash/" rel="tag">hash <span class="tag-num">3</span></a><a class="badge badge-secondary tag" href="/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/" rel="tag">主席树 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E4%B9%B1%E6%90%9E/" rel="tag">乱搞 <span class="tag-num">6</span></a><a class="badge badge-secondary tag" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/" rel="tag">二分图匹配 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/" rel="tag">二分答案 <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/%E4%BA%8C%E7%BB%B4SPFA/" rel="tag">二维SPFA <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E4%BA%A4%E4%BA%92/" rel="tag">交互 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他 <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/%E5%88%86%E5%9D%97/" rel="tag">分块 <span class="tag-num">6</span></a><a class="badge badge-secondary tag" href="/tags/%E5%8C%BA%E9%97%B4DP/" rel="tag">区间DP <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/" rel="tag">半平面交 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论 <span class="tag-num">4</span></a><a class="badge badge-secondary tag" href="/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/" rel="tag">可持久化 <span class="tag-num">3</span></a><a class="badge badge-secondary tag" href="/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96Trie%E6%A0%91/" rel="tag">可持久化Trie树 <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" rel="tag">后缀数组 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E5%9B%BE%E5%BA%93/" rel="tag">图库 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" rel="tag">平衡树 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E6%8F%92%E5%A4%B4DP/" rel="tag">插头DP <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学 <span class="tag-num">6</span></a><a class="badge badge-secondary tag" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论 <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/%E6%97%A0%E6%97%8BTreap/" rel="tag">无旋Treap <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E6%97%A5%E8%AE%B0/" rel="tag">日记 <span class="tag-num">6</span></a><a class="badge badge-secondary tag" href="/tags/%E6%9A%B4%E5%8A%9B/" rel="tag">暴力 <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E6%9D%83%E5%80%BC%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" rel="tag">权值树状数组 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E6%A0%88/" rel="tag">栈 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E6%A0%91DP/" rel="tag">树DP <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/%E6%A0%91%E5%A5%97%E6%A0%91/" rel="tag">树套树 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" rel="tag">树状数组 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E6%A0%91%E8%B4%AA%E5%BF%83/" rel="tag">树贪心 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E6%A6%82%E7%8E%87DP/" rel="tag">概率DP <span class="tag-num">13</span></a><a class="badge badge-secondary tag" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟 <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/" rel="tag">欧拉定理 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E7%82%B9%E5%88%86%E6%B2%BB/" rel="tag">点分治 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E7%8A%B6%E5%8E%8BDP/" rel="tag">状压DP <span class="tag-num">5</span></a><a class="badge badge-secondary tag" href="/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" rel="tag">生成函数 <span class="tag-num">5</span></a><a class="badge badge-secondary tag" href="/tags/%E7%9F%A9%E9%98%B5%E4%B9%98/" rel="tag">矩阵乘 <span class="tag-num">5</span></a><a class="badge badge-secondary tag" href="/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/" rel="tag">线性规划 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树 <span class="tag-num">5</span></a><a class="badge badge-secondary tag" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流 <span class="tag-num">6</span></a><a class="badge badge-secondary tag" href="/tags/%E7%BE%A4%E8%AE%BA/" rel="tag">群论 <span class="tag-num">3</span></a><a class="badge badge-secondary tag" href="/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/" rel="tag">莫比乌斯反演 <span class="tag-num">4</span></a><a class="badge badge-secondary tag" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" rel="tag">计算几何 <span class="tag-num">1</span></a><a class="badge badge-secondary tag" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心 <span class="tag-num">6</span></a><a class="badge badge-secondary tag" href="/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/" rel="tag">费用流 <span class="tag-num">2</span></a><a class="badge badge-secondary tag" href="/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/" rel="tag">高斯消元 <span class="tag-num">6</span></a></div></div></div></div><div id="primary" class="content-area"><main id="main" class="site-main" role="main"><article class="post post-full card bg-white shadow-sm border-0 post-preview"><header class="post-header text-center"><a class="post-title" href="/2019/07/31/templates/">模板库</a><div class="post-meta"><div class="post-meta-detail post-meta-detail-time"><i class="fa fa-clock-o" aria-hidden="true"></i> <time title="发布于 2019-7-31 11:04:10 | 编辑于 2023-9-26 23:54:26">2019-7-31 11:04</time></div><div class="post-meta-devide">|</div><div class="post-meta-detail post-meta-detail-categories"><i class="fa fa-bookmark-o" aria-hidden="true"></i> <a class="post-meta-detail-catagory-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post-meta-devide">|</div><div class="post-meta-detail post-meta-detail-words"><i class="fa fa fa-book" aria-hidden="true"></i> <span id="busuanzi_container_page_pv">阅读<span id="busuanzi_value_page_pv"></span>次</span></div><div class="post-meta-devide">|</div><div class="post-meta-detail post-meta-detail-words"><i class="fa fa-file-word-o" aria-hidden="true"></i> 10.7k 字</div><div class="post-meta-devide">|</div><div class="post-meta-detail post-meta-detail-readingtime"><i class="fa fa-hourglass-end" aria-hidden="true"></i> 64 分钟</div></div></header><div class="post-content" id="post_content"><ol><li>算法 (AG)<ol><li>网络流 (NF)<ol><li>网络流线性规划<ol><li>上下界网络流</li><li>最小割</li><li>费用流</li></ol></li><li>Edmond-Karp (EK)<ol><li>Capacity Scaling</li><li>Dinic&amp;SAP</li><li>HLPP</li></ol></li></ol></li><li>差分约束 (DC)</li><li>通用线性规划 (LP)<ol><li>单纯形算法</li></ol></li><li>分数规划 (FP)</li><li>贪心 (GE)</li><li>分治 (DAC)<ol><li>序列分治<ol><li><a href="#CDQ">CDQ&amp;<del>整体二分&amp;线段树分治</del></a></li><li><input disabled type="checkbox"> 快速排序<ol><li>快速选择<ol><li>Median of Medians</li></ol></li></ol></li></ol></li><li>树分治<ol><li><a href="#%E7%82%B9%E5%88%86%E6%B2%BB">点/<del>边</del>分治</a></li><li>重链剖分<ol><li>树上启发式合并</li><li>长链剖分</li></ol></li></ol></li></ol></li><li>搜索 (SR)<ol><li>搜索优化与剪枝<ol><li><a href="#Astar">A* (AS)</a></li><li>迭代加深搜索 (ID)</li></ol></li><li>折半搜索 (MIM)</li></ol></li><li>随机化及近似 (RAN)<ol><li><del>爬山</del></li><li><a href="#%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB">模拟退火</a></li><li><del>遗传算法</del></li><li><del>机器学习基础</del></li></ol></li><li>离线逆序<ol><li><a href="#%E8%8E%AB%E9%98%9F">莫队算法</a></li></ol></li><li><a href="#%E7%A6%BB%E6%95%A3%E5%8C%96">散列 (HS)</a></li></ol></li><li>数据结构 (DS)<ol><li>栈 (STK) =&gt; STL</li><li>队列 (QUE) =&gt; STL</li><li><a href="#Hash_Table">散列表 (HST)</a></li><li>堆 (HP)<ol><li>二叉堆</li><li>可并堆</li></ol></li><li>二叉查找树 (BST)<ol><li>堆树 (THP)</li><li><a href="#Treap">Treap</a></li><li>红黑树 (RBT)</li><li><a href="#%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91">替罪羊树 (SGT)</a></li></ol></li><li><a href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">树状数组 (BIT)</a></li><li><a href="#%E7%BA%BF%E6%AE%B5%E6%A0%91">线段树 (SGM)</a></li><li><a href="#%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集 (UFS)</a><ol><li>带权并查集</li><li>路径压缩</li><li>按秩合并</li></ol></li><li><a href="#ST">Sparse Table (ST)</a></li><li><a href="#KD-Tree">K维树 (KDT)</a></li><li>动态树<ol><li>点/边分治树 (DCT)</li><li><a href="#LCT">Link-Cut Tree (LCT)</a></li><li>欧拉回路树 (ETT)</li><li>AAA Tree &amp; Top Tree</li></ol></li><li>动态图</li></ol></li><li>图论 (GT)<ol><li>最小生成树<ol><li>Prim 算法 (PM)</li><li>Kruskal 算法 (KS)<ol><li>Boruvka 算法</li></ol></li><li>最小树形图<ol><li>朱-刘算法</li></ol></li><li>斯坦纳树</li></ol></li><li>最短路径<ol><li><a href="#Dijkstra">dijkstra 算法 (DJ)</a></li><li><a href="#SPFA">Bellman-Ford 算法 (BFD)</a><ol><li>Johnson 算法</li></ol></li><li>Floyd 算法 (FL)</li></ol></li><li>欧拉路&amp;哈密顿路</li><li>连通性<ol><li>点/边双连通分量 (BCC)</li><li>强连通性 (SCC)</li><li>支配树</li></ol></li><li>匹配、划分与覆盖<ol><li>KM 算法 (KM)<ol><li>交错树</li><li>带花树算法 (BL)</li><li>Tutte 矩阵与一般图匹配</li></ol></li><li>覆盖集与独立集</li><li>稳定婚姻问题与 GS 算法 (GS)</li><li>Hall 定理</li><li>DAG 路径覆盖</li><li>Dilworth 定理</li></ol></li><li>2-SAT</li><li>虚树</li><li>仙人掌<ol><li>圆方树</li></ol></li><li>弦图与区间图</li><li>图的树分解</li><li>最小割<ol><li>最小割树</li><li>Stoer-Wagner 算法</li></ol></li><li>平面图<ol><li>平面图对偶图</li></ol></li><li>网格图</li></ol></li><li>计算几何 (CG)<ol><li>几何向量</li><li>二维凸包<ol><li>凸包算法<ol><li>卷包裹法</li><li>动态凸包</li></ol></li><li>三维凸包</li><li>半平面交</li></ol></li><li>旋转卡壳</li><li>三角剖分<ol><li>V图</li></ol></li><li>路径规划</li></ol></li><li>代数 (AB)<ol><li>微积分基础<ol><li>Simpson 积分算法</li></ol></li><li>线性代数<ol><li>矩阵基础<ol><li><a href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83">高斯消元</a></li><li>拟阵</li><li>Matrix-Tree 定理</li><li>线性递推</li></ol></li></ol></li><li>多项式与幂级数<ol><li><a href="#FFT">DFT/FFT (FT)</a><ol><li><a href="#NTT">NTT</a></li><li>Bluestein 算法</li></ol></li><li><a href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F">多项式基本运算</a><ol><li>多项式除法</li><li>多项式基本初等函数</li></ol></li><li>FWT (FWT)<ol><li>子集变换</li></ol></li></ol></li><li>抽象代数<ol><li>置换群<ol><li>Schreier-Sims 算法</li></ol></li></ol></li></ol></li><li>数论 (NT)<ol><li>同余和整除<ol><li>欧几里得算法<ol><li>扩展欧几里得算法</li><li>类欧几里得算法</li></ol></li><li>欧拉定理</li><li>二次剩余</li><li>原根及离散对数<ol><li><a href="#BSGS&exBSGS">BSGS</a></li></ol></li><li>lucas 定理</li></ol></li><li>质数与简单数论函数<ol><li>埃氏筛</li><li><a href="#%E7%BA%BF%E6%80%A7%E7%AD%9B">欧拉筛</a></li><li>莫比乌斯反演</li><li>数论函数快速求和<ol><li><a href="#%E6%9D%9C%E6%95%99%E7%AD%9B">杜教筛</a></li><li>洲阁筛</li></ol></li><li>素性测试<ol><li><a href="#Miller_Robin">Miller-Robin (MR)</a></li><li><a href="#Miller_Robin">Pollard’s Rho 因子分解</a></li></ol></li></ol></li></ol></li><li>组合计数 (CE)<ol><li>计数原理<ol><li>容斥原理</li></ol></li><li>计数数列<ol><li>斯特林数</li><li>卡特兰数</li><li>伯努利数</li></ol></li><li>生成函数 (GF)</li><li>杨氏矩阵</li><li>Burnside 引理<ol><li>Polya 定理</li></ol></li></ol></li><li>博弈论与信息论 (GI)<ol><li>博弈基础<ol><li>组合游戏<ol><li>博弈树与 DAG 模型</li><li>Sprague-Grundy 函数 (SG)</li><li>Nim (NIM)<ol><li>Nim 积</li></ol></li><li>威佐夫博弈</li></ol></li><li>不平等博弈<ol><li>超现实数</li></ol></li><li>不完全信息博弈</li></ol></li><li>通信与数据压缩<ol><li>校验码</li><li>哈夫曼编码</li><li>游程编码</li></ol></li></ol></li><li>形式语言，自动机与串处理 (FAS)<ol><li>串处理 (STR)<ol><li>模式匹配<ol><li><a href="#KMP&EXKMP">KMP 算法 (KMP) &amp;&amp; EXKMP</a></li><li>AC 自动机</li><li>Shift-And 算法</li></ol></li><li>字典树 (TRI)<ol><li>后缀树<ol><li>后缀数组 (SA)</li><li>后缀自动机 (SAM)</li></ol></li></ol></li><li>Border<ol><li>Periodicity 引理</li></ol></li><li>回文串<ol><li>manacher 算法</li><li>回文自动机 (PAM)</li></ol></li></ol></li><li>形式语言<ol><li>正则表达式 (RE)</li><li>有限状态自动机 (DFA)</li></ol></li><li>并行计算</li></ol></li></ol><h5 id="CDQ"><a href="#CDQ" class="headerlink" title="CDQ"></a>CDQ</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAXN = 800005;
struct Query
&#123;
    int x, y, op, val, id, pos;
    bool operator &lt; (const Query &amp;a) const
    &#123;
        return x == a.x ? op &lt; a.op : x &lt; a.x;
    &#125;
&#125; Ask[MAXN], tmp[MAXN];
int n, m, Ans[MAXN];
#define lowbit(_) ((_)&amp;(-_))
struct BIT
&#123;
    int Sum[2000005];
    void add(int x, int c)
    &#123;
        for (int i = x; i &lt;= n; i += lowbit(i))
            Sum[i] += c;
    &#125;
    int Query(int x)
    &#123;
        int ans = 0;
        for (int i = x; i &gt; 0; i -= lowbit(i))
            ans += Sum[i];
        return ans;
    &#125;
&#125;bit;
void add()
&#123;
    int x1, y1, x2, y2;
    scanf (&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
    ++Ans[0];
    Ask[++m].pos = Ans[0], Ask[m].x = x1 - 1, Ask[m].y = y1 - 1, Ask[m].val = 1, Ask[m].op = 1;
    Ask[++m].pos = Ans[0], Ask[m].x = x2    , Ask[m].y = y2    , Ask[m].val = 1, Ask[m].op = 1;
    Ask[++m].pos = Ans[0], Ask[m].x = x1 - 1, Ask[m].y = y2    , Ask[m].val =-1, Ask[m].op = 1;
    Ask[++m].pos = Ans[0], Ask[m].x = x2    , Ask[m].y = y1 - 1, Ask[m].val =-1, Ask[m].op = 1;
&#125;
void CDQ(int l, int r)
&#123;
    if (l == r)
        return;
    int mid = l + r &gt;&gt; 1, l1 = l, l2 = mid + 1;
    for (int i = l; i &lt;= r; i++)
    &#123;
        if (Ask[i].id &lt;= mid &amp;&amp; !Ask[i].op)
            bit.add(Ask[i].y, Ask[i].val);
        if (Ask[i].id &gt; mid &amp;&amp; Ask[i].op)
            Ans[Ask[i].pos] += Ask[i].val * bit.Query(Ask[i].y);
    &#125;
    for (int i = l; i &lt;= r; i++)
        if (Ask[i].id &lt;= mid &amp;&amp; !Ask[i].op)
            bit.add(Ask[i].y, -Ask[i].val);
    for (int i = l; i &lt;= r; i++)
    &#123;
        if (Ask[i].id &lt;= mid)
            tmp[l1++] = Ask[i];
        else tmp[l2++] = Ask[i];
    &#125;
    for (int i = l; i &lt;= r; i++)
        Ask[i] = tmp[i];
    CDQ(l, mid);
    CDQ(mid + 1, r);
    return;
&#125;
int main()
&#123;
    freopen(&quot;mokia.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;mokia.out&quot;, &quot;w&quot;, stdout);
    int op;
    scanf (&quot;%d%d&quot;, &amp;op, &amp;n);
    while (1)
    &#123;
        scanf (&quot;%d&quot;, &amp;op);
        if (op == 1)
        &#123;
            m++;
            scanf (&quot;%d%d%d&quot;, &amp;Ask[m].x, &amp;Ask[m].y, &amp;Ask[m].val);
        &#125;
        else if (op == 2)
            add();
        else break;
    &#125;
    for (int i = 1; i &lt;= m; i++)
        Ask[i].id = i;
    sort(Ask + 1, Ask + m + 1);
    CDQ(1 ,m);
    for (int i = 1; i &lt;= Ans[0]; i++)
        printf (&quot;%d\n&quot;, Ans[i]);
&#125;
</code></pre><h5 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

inline int read()
&#123;
    int x=0,f=1;char ch=getchar();
    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125;
    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)&#123;x=x*10+ch-&#39;0&#39;;ch=getchar();&#125;
    return x*f;
&#125;

const int MAXN = 20005;

struct edge
&#123;
    int END, next;
    int v;
&#125;v[MAXN &lt;&lt; 1]; 
int first[MAXN], p;
void add(int a, int b, int c)
&#123;
    v[p].END = b;
    v[p].next = first[a];
    v[p].v = c;
    first[a] = p++;
&#125;
int size[MAXN], Max[MAXN], ans, sum, t[3], d[MAXN];
bool vis[MAXN];
int root;
void Get_root(int rt, int fa)
&#123;
    size[rt] = 1, Max[rt] = 0;
    for (int i = first[rt]; i != -1; i = v[i].next)
    &#123;
        if (!vis[v[i].END] &amp;&amp; v[i].END != fa)
        &#123;
            Get_root(v[i].END, rt);
            size[rt] += size[v[i].END];
            Max[rt] = max(Max[rt], size[v[i].END]);
        &#125;
    &#125;
    Max[rt] = max(Max[rt], sum - size[rt]);
    if (Max[rt] &lt; Max[root]) root = rt;
&#125;

void dfs(int rt, int fa)
&#123;
    t[d[rt]]++;
    for (int i = first[rt]; i != -1; i = v[i].next)
    &#123;
        if (!vis[v[i].END] &amp;&amp; v[i].END != fa)
        &#123;
            d[v[i].END] = (d[rt] + v[i].v) % 3;
            dfs(v[i].END, rt);
        &#125;
    &#125;
&#125;

int Calc(int rt, int x)
&#123;
    t[0] = t[1] = t[2] = 0;
    d[rt] = x;
    dfs(rt, 0);
    return t[1] * t[2] * 2 + t[0] * t[0];
&#125;

void Solve(int rt)
&#123;
    ans += Calc(rt, 0);
    vis[rt] = 1;
    for (int i = first[rt]; i != -1; i = v[i].next)
    &#123;
        if (!vis[v[i].END])
        &#123;
            ans -= Calc(v[i].END, v[i].v);
            root = 0, sum = size[v[i].END];
            Get_root(v[i].END, 0);
            Solve(root);
        &#125;
    &#125;
&#125;

int gcd(int a, int b)
&#123;
    return b == 0 ? a : gcd(b, a % b);
&#125;

int main()
&#123;
    memset (first, -1, sizeof (first));
    int n = read();
    int a, b, c;
    for (int i = 1; i &lt; n; i++)
    &#123;
        a = read(), b = read(), c = read() % 3;
        add(a, b, c);
        add(b, a, c);
    &#125;
    Max[0] = sum = n;
    Get_root(1, 0);
    Solve(root);
    int G = gcd(ans, n * n);
    printf (&quot;%d/%d\n&quot;, ans / G, n * n / G);
&#125;
</code></pre><h5 id="Astar"><a href="#Astar" class="headerlink" title="Astar"></a>Astar</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;
struct edge &#123;
  int END, v, next;
&#125; ZHENG[10005], FAN[10005];
struct A &#123;
  int END, f, g;
  bool operator&lt;(const A &amp;a) const &#123;
    if (f == a.f) return a.g &lt; g;
    return a.f &lt; f;
  &#125;
&#125;;
int first_zheng[1005], first_fan[1005], p;
int dis[1005];
int n;
int s;
void add(int a, int b, int c);
void spfa(int a);
int Astar(int k);
int main() &#123;
  freopen(&quot;cowjog.in&quot;, &quot;r&quot;, stdin);
  freopen(&quot;cowjog.out&quot;, &quot;w&quot;, stdout);
  // cin&gt;&gt;n&gt;&gt;m;
  memset(first_fan, -1, sizeof(first_fan));
  memset(first_zheng, -1, sizeof(first_zheng));
  p = 1;
  int m, a, b, c, K;
  scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;K);
  for (int i = 1; i &lt;= m; i++) &#123;
    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
    if (a &gt; b)
      add(a, b, c);
    else
      add(b, a, c);
  &#125;
  spfa(1);
  for (int k = 1; k &lt;= K; k++) &#123;
    s = 0;
    cout &lt;&lt; Astar(k) &lt;&lt; endl;
  &#125;
  // while(1);
&#125;
void add(int a, int b, int c) &#123;
  ZHENG[p].END = b;
  ZHENG[p].v = c;
  ZHENG[p].next = first_zheng[a];
  FAN[p].END = a;
  FAN[p].v = c;
  FAN[p].next = first_fan[b];
  first_zheng[a] = p;
  first_fan[b] = p++;
&#125;
void spfa(int a) &#123;
  memset(dis, 0x3f, sizeof(dis));
  dis[a] = 0;
  bool flag[1005] = &#123;0&#125;;
  queue&lt;int&gt; p;
  p.push(a);
  flag[a] = 1;
  while (!p.empty()) &#123;
    int tmp = p.front();
    flag[tmp] = 0;
    p.pop();
    for (int i = first_fan[tmp]; i != -1; i = FAN[i].next) &#123;
      if (dis[FAN[i].END] &gt; dis[tmp] + FAN[i].v) &#123;
        dis[FAN[i].END] = dis[tmp] + FAN[i].v;
        if (!flag[FAN[i].END]) &#123;
          flag[FAN[i].END] = 1;
          p.push(FAN[i].END);
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
int Astar(int k) &#123;
  priority_queue&lt;A&gt; p;
  A s1, s2;
  s1.END = n;
  s1.g = 0;
  s1.f = s1.g + dis[n];
  p.push(s1);
  while (!p.empty()) &#123;
    s2 = p.top();
    p.pop();
    if (s2.END == 1) &#123;
      s++;
      if (s == k) return s2.g;
    &#125;
    for (int i = first_zheng[s2.END]; i != -1; i = ZHENG[i].next) &#123;
      s1.END = ZHENG[i].END;
      s1.g = s2.g + ZHENG[i].v;
      s1.f = s1.g + dis[ZHENG[i].END];
      p.push(s1);
    &#125;
  &#125;
  return -1;
&#125;
</code></pre><h5 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;ctime&gt;
using namespace std;
const double pi = acos(-1.);
const double eps = 1e-10;
const int seed = time(0);
inline int read()
&#123;
    int x=0,f=1;char ch=getchar();
    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125;
    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)&#123;x=x*10+ch-&#39;0&#39;;ch=getchar();&#125;
    return x*f;
&#125;
double Rand()
&#123;
    return 1.0 * rand() / RAND_MAX;
&#125;
struct Point
&#123;
    double x, y, k;
    Point(double _x = 0, double _y = 0): x(_x), y(_y) &#123;
        k = atan2(y, x);
    &#125;
    Point operator - (const Point &amp;_x)
    &#123;
        return Point(x - _x.x, y - _x.y);
    &#125;
    double operator * (const Point &amp;_x)
    &#123;
        return x * _x.y - y * _x.x;
    &#125;
    bool operator &lt; (const Point &amp;_x) const
    &#123;
        return k &gt; _x.k;
    &#125;
&#125;a[10], tmp[10];
int cnt = 0;
double area(Point *x, int n)
&#123;
    double ans = 0;
    cnt++;
    sort(x + 1, x + n + 1);
    Point t(0, 0);
    for (int i = 1; i &lt;= n - 1; i++)
        ans += (x[i] - t) * (x[i + 1] - t);
    ans += (x[n] - t) * (x[1] - t);
    return fabs(ans);
&#125;
int r[10];
bool cmp(const int &amp;a, const int &amp;b)
&#123;
    return a &gt; b;
&#125;
double dis(Point &amp;x, Point &amp;y)
&#123;
    return (x.x - y.x) * (x.x - y.x) + (x.y - y.y) * (x.y - y.y);
&#125;
bool cmp1(Point x, Point y)
&#123;
    double s = (x - tmp[1]) * (y - tmp[1]);
    if (fabs(s) &lt;= eps) return dis(x, tmp[1]) &lt; dis(y, tmp[1]);
    return s &gt; 0;
&#125;
int st[10], top;
double Calc(Point *x, int n)
&#123;
    memcpy(tmp, x, sizeof (tmp));
    int k = 0;
    for (int i = 1; i &lt;= n; i++)
        if (tmp[i].x &lt; tmp[k].x &amp;&amp; tmp[i].y &lt; tmp[k].y || !k)
            k = i;
    swap(tmp[1], tmp[k]);
    sort(tmp + 2, tmp + n + 1, cmp1);
    top = 0;
    st[++top] = 1;
    for (int i = 2; i &lt;= n; i++)
    &#123;
        while (top &gt; 1 &amp;&amp; (tmp[st[top]] - tmp[st[top - 1]]) * (tmp[i] - tmp[st[top]]) &lt; 0) top--;
        st[++top] = i;
    &#125;
    for (int i = 1; i &lt;= top; i++)
        tmp[i] = tmp[st[i]];
    return area(tmp, top);
&#125;
double T = 1e9, mint = 1e-9, delta = 1 - 1e-2;
int loop = 50;
double w[10];
int main()
&#123;
    // freopen (&quot;1.out&quot;, &quot;w&quot;, stdout);
    srand(seed);
    int n = read();
    for (int i = 1; i &lt;= n; i++) r[i] = read();
    for (int i = 1; i &lt;= n; i++) w[i] = Rand() * 2 * pi;
    for (int i = 1; i &lt;= n; i++) a[i].x = cos(w[i]) * r[i], a[i].y = sin(w[i]) * r[i];
    double ans = Calc(a, n);
    while (T &gt; mint)
    &#123;
        for (int i = 1; i &lt;= loop; i++)
        &#123;
            int t = rand() % n + 1;
            double tmp_w = w[t];
            w[t] = w[t] + Rand() * 2 * pi * T;
            // if (w[t] &gt; 2 * pi) w[t] -= 2 * pi;
            a[t].x = cos(w[t]) * r[t], a[t].y = sin(w[t]) * r[t];
            double tmp = Calc(a, n);
            // printf (&quot;%.2f\n&quot;, (tmp - ans) / T);
            // printf (&quot;%.2f\n&quot;, exp((tmp - ans) / T));
            if (tmp &gt; ans || exp((tmp - ans) / T) &gt; Rand()) 
                ans = tmp;
            else
            &#123;
                w[t] = tmp_w;
                a[t].x = cos(w[t]) * r[t], a[t].y = sin(w[t]) * r[t];
            &#125;
        &#125;
        T *= delta;
    &#125;
    printf (&quot;%.10f\n&quot;, ans / 2);
    // while (1);
&#125;
</code></pre><h5 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
int a[50005], in[50005];
int block = 500;
struct Query
&#123;
    int l, r, ID;
    bool operator &lt; (const Query &amp;b) const 
    &#123;
        return in[l] == in[b.l] ? r &gt; b.r : l &lt; b.l;
    &#125;
&#125;Q[200005];
int cnt[1000005];
int out[200005];
int main()
&#123;
    int n, m, ans = 0;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;a[i]);    
        in[i] = (i - 1) / block + 1;
        cnt[a[i]]++;
        if(cnt[a[i]] == 1)
            ans++;
    &#125;
    scanf(&quot;%d&quot;, &amp;m);
    for (int i = 1; i &lt;= m; i++)
        scanf(&quot;%d%d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].ID = i;
    sort(Q + 1, Q + m + 1);
    int l = 1, r = n + 1;
    for (int i = 1; i &lt;= m; i++)
    &#123;
        while(l &lt; Q[i].l) &#123;cnt[a[l]]--; if(cnt[a[l]] == 0) ans--; l++;&#125;
        while(l &gt; Q[i].l) &#123;l--; cnt[a[l]]++; if(cnt[a[l]] == 1) ans++;&#125;
        while(r &gt; Q[i].r) &#123;cnt[a[r]]--; if(cnt[a[r]] == 0) ans--; r--;&#125;
        while(r &lt; Q[i].r) &#123;r++; cnt[a[r]]++; if(cnt[a[r]] == 1) ans++;&#125;
        out[Q[i].ID] = ans;
    &#125;
    for (int i = 1; i &lt;= m; i++)
        printf(&quot;%d\n&quot;, out[i]);
&#125;
</code></pre><h5 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h5><pre><code class="c++">cnt = 0;
for (int i = 1; i &lt;= n; i++) &#123;
  a[i] = read();
  Hash[++cnt] = a[i];
&#125;
sort(Hash + 1, Hash + cnt + 1);
cnt = unique(Hash + 1, Hash + cnt + 1) - Hash - 1;
for (int i = 1; i &lt;= n; i++) &#123;
  a[i] = lower_bound(Hash + 1, Hash + cnt + 1, a[i]) - Hash;
&#125;
</code></pre><h5 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash_Table"></a>Hash_Table</h5><pre><code class="c++">const int MAXN = 200000, BASE = 76543;
struct Hash_Table
&#123;
    struct edge
    &#123;
        int Id, next;
        long long Max;
    &#125;v[MAXN];
    int first[BASE + 2], p;
    Hash_Table()
    &#123;
        memset (first, -1, sizeof (first));
        p = 0;
    &#125;
    void clear()
    &#123;
        memset (first, -1, sizeof (first));
        p = 0;
    &#125;
    long long &amp;operator[](int x)
    &#123;
        int H = x % BASE;
        for (int i = first[H]; i != -1; i = v[i].next)
            if (v[i].Id == x)
                return v[i].Max;
        v[p].Id = x;
        v[p].next = first[H];
        first[H] = p++;
        return v[p - 1].Max = -INF;
    &#125;
&#125;Hash;
</code></pre><h5 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h5><pre><code class="c++">struct Treap
&#123;
    struct Node
    &#123;
        int s, key, Max_Num, Max_Size;
        data x;
        Node *ch[2];
        Node(data sa)
        &#123;
            ch[0] = ch[1] = NULL;
            s = 1, x = sa, key = rand();
            Max_Num = Max_Size = 0;
        &#125;
#define size(_) ((_) ? (_)-&gt;s : 0)
        void Pushup()
        &#123;
            s = size(ch[0]) + size(ch[1]) + 1;
        &#125;
        void Pushdown()
        &#123;
            if (ch[0])
            &#123;
                ch[0]-&gt;Max_Num = max(ch[0]-&gt;Max_Num, Max_Num);
                ch[0]-&gt;Max_Size = max(ch[0]-&gt;Max_Size, Max_Size);
                Max_Morale[ch[0]-&gt;x.ID] = max(Max_Morale[ch[0]-&gt;x.ID], ch[0]-&gt;Max_Num);
                Max_Solidarity[ch[0]-&gt;x.ID] = max(Max_Solidarity[ch[0]-&gt;x.ID], ch[0]-&gt;Max_Size);
            &#125;
            if (ch[1])
            &#123;
                ch[1]-&gt;Max_Num = max(ch[1]-&gt;Max_Num, Max_Num);
                ch[1]-&gt;Max_Size = max(ch[1]-&gt;Max_Size, Max_Size);
                Max_Morale[ch[1]-&gt;x.ID] = max(Max_Morale[ch[1]-&gt;x.ID], ch[1]-&gt;Max_Num);
                Max_Solidarity[ch[1]-&gt;x.ID] = max(Max_Solidarity[ch[1]-&gt;x.ID], ch[1]-&gt;Max_Size);
            &#125;
            Max_Num = Max_Size = 0;
        &#125;
    &#125; * root;
    Treap()
    &#123;
        root = NULL;
    &#125;
    Node *Merge(Node *A, Node *B)
    &#123;
        if (!A)
            return B;
        if (!B)
            return A;
        if (A-&gt;key &lt; B-&gt;key)
        &#123;
            A-&gt;Pushdown();
            A-&gt;ch[1] = Merge(A-&gt;ch[1], B);
            A-&gt;Pushup();
            return A;
        &#125;
        else
        &#123;
            B-&gt;Pushdown();
            B-&gt;ch[0] = Merge(A, B-&gt;ch[0]);
            B-&gt;Pushup();
            return B;
        &#125;
    &#125;
    typedef pair&lt;Node *, Node *&gt; DNode;
    DNode Split(Node *rt, int k)
    &#123;
        if (!rt)
            return DNode(NULL, NULL);
        DNode o;
        rt-&gt;Pushdown();
        if (size(rt-&gt;ch[0]) &gt;= k)
        &#123;
            o = Split(rt-&gt;ch[0], k);
            rt-&gt;ch[0] = o.second;
            rt-&gt;Pushup();
            o.second = rt;
        &#125;
        else
        &#123;
            o = Split(rt-&gt;ch[1], k - size(rt-&gt;ch[0]) - 1);
            rt-&gt;ch[1] = o.first;
            rt-&gt;Pushup();
            o.first = rt;
        &#125;
        return o;
    &#125;
    Node *kth(int k)
    &#123;
        DNode x = Split(root, k - 1);
        DNode y = Split(x.second, 1);
        Node *ans = y.first;
        root = Merge(Merge(x.first, ans), y.second);
        return ans;
    &#125;
    int Rank(Node *rt, data x)
    &#123;
        if (!rt)
            return 0;
        return x &lt;= rt-&gt;x ? Rank(rt-&gt;ch[0], x) : Rank(rt-&gt;ch[1], x) + size(rt-&gt;ch[0]) + 1;
    &#125;
    void Insert(data x)
    &#123;
        int k = Rank(root, x);
        if (root)
        &#123;
            root-&gt;Max_Size = max(root-&gt;Max_Size, size(root));
            root-&gt;Max_Num = max(root-&gt;Max_Num, x.x);
            Max_Morale[root-&gt;x.ID] = max(root-&gt;Max_Num, Max_Morale[root-&gt;x.ID]);
            Max_Solidarity[root-&gt;x.ID] = max(root-&gt;Max_Size, Max_Solidarity[root-&gt;x.ID]);
        &#125;
        DNode y = Split(root, k);
        Node *n = new Node(x);
        root = Merge(Merge(y.first, n), y.second);
    &#125;
    void remove(data x)
    &#123;
        int k = Rank(root, x);
        DNode a = Split(root, k);
        DNode b = Split(a.second, 1);
        delete b.first;
        root = Merge(a.first, b.second);
    &#125;
&#125;;
</code></pre><h5 id="替罪羊树"><a href="#替罪羊树" class="headerlink" title="替罪羊树"></a>替罪羊树</h5><pre><code class="c++">namespace Scapegoat_Tree
&#123;
    const int MAXN = 1e6 + 10;
    const double alpha = 0.756;
    struct Node
    &#123;
        Node *ch[2];
        int key, s, cover;
        bool exist;
        void Pushup()
        &#123;
            s = ch[0]-&gt;s + ch[1]-&gt;s + exist;
            cover = ch[0]-&gt;cover + ch[1]-&gt;cover + 1;
        &#125;
        bool isBad()
        &#123;
            return ((ch[0]-&gt;cover &gt; cover * alpha + 5) || (ch[1]-&gt;cover &gt; cover * alpha + 5));
        &#125;
    &#125;;
    struct Stree 
    &#123;
        Node mem_poor[MAXN];
        Node *tail, *root, *null, *ls[MAXN];
        Node *bc[MAXN]; int bc_top, top;
        Node *NewNode(int key)
        &#123;
            Node *o = bc_top ? bc[--bc_top] : tail++;
            o-&gt;ch[0] = o-&gt;ch[1] = null;
            o-&gt;s = o-&gt;cover = o-&gt;exist = 1;
            o-&gt;key = key;
            return o;
        &#125;
        void Travel(Node *rt)
        &#123;
            if (rt == null) return;
            Travel(rt-&gt;ch[0]);
            if (rt-&gt;exist) ls[++top] = rt;
            else bc[bc_top++] = rt;
            Travel(rt-&gt;ch[1]);
        &#125;
        Node *Divide(int l, int r)
        &#123;
            if (l &gt; r) return null;
            int mid = (l + r) &gt;&gt; 1;
            Node *o = ls[mid];
            o-&gt;ch[0] = Divide(l, mid - 1);
            o-&gt;ch[1] = Divide(mid + 1, r);
            o-&gt;Pushup();
            return o;
        &#125;
        void ReBuild(Node *&amp;rt)
        &#123;
            top = 0;
            Travel(rt);
            rt = Divide(1, top);
        &#125;
        Node ** Insert(Node *&amp;rt, int val)
        &#123;
            if (rt == null) 
            &#123;
                rt = NewNode(val);
                return &amp;null;
            &#125;
            else
            &#123;
                Node **res = Insert(rt-&gt;ch[val &gt;= rt-&gt;key], val);
                rt-&gt;Pushup();
                if (rt-&gt;isBad()) res = &amp;rt;
                return res;
            &#125;
        &#125;
        void erase(Node *rt, int id)
        &#123;
            rt-&gt;s--;
            int offset = rt-&gt;ch[0]-&gt;s + rt-&gt;exist;
            if (rt-&gt;exist &amp;&amp; id == offset)
            &#123;
                rt-&gt;exist = false;
                return;
            &#125;
            else
            &#123;
                if (id &lt;= offset) erase(rt-&gt;ch[0], id);
                else erase(rt-&gt;ch[1], id - offset);
            &#125;
        &#125;
        Stree()
        &#123;
            tail = mem_poor;
            null = tail++;
            null-&gt;ch[0] = null-&gt;ch[1] = null;
            null-&gt;cover = null-&gt;s = null-&gt;key = 0;
            root = null; bc_top = 0;
        &#125;
        void Insert(int val)
        &#123;
            Node **rt = Insert(root, val);
            if (*rt != null) ReBuild(*rt);
        &#125;
        int Rank(int val)
        &#123;
            Node *rt = root;
            int ans = 1;
            while (rt != null)
            &#123;
                if (rt-&gt;key &gt;= val) rt = rt-&gt;ch[0];
                else
                &#123;
                    ans += rt-&gt;ch[0]-&gt;s + rt-&gt;exist;
                    rt = rt-&gt;ch[1];
                &#125;
            &#125;
            return ans;
        &#125;
        int Kth(int k)
        &#123;
            Node *rt = root;
            while (rt != null)
            &#123;
                if (rt-&gt;ch[0]-&gt;s + 1 == k &amp;&amp; rt-&gt;exist) return rt-&gt;key;
                else if (rt-&gt;ch[0]-&gt;s &gt;= k) rt = rt-&gt;ch[0];
                else k -= rt-&gt;ch[0]-&gt;s + rt-&gt;exist, rt = rt-&gt;ch[1];
            &#125;
        &#125;
        void erase(int k)
        &#123;
            erase(root, Rank(k));
            if (root-&gt;s &lt; alpha * root-&gt;cover) ReBuild(root);
        &#125;
    &#125;;
&#125;
</code></pre><h5 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h5><pre><code class="c++">const int MAXN = 60005 &lt;&lt; 2;
const double pi = acos(-1.0);
#define Complex complex&lt;double&gt;
int r[MAXN], n;
Complex a[MAXN], b[MAXN];
void DFT(Complex *a, int f)
&#123;
    for (int i = 0; i &lt; n; i++)
        if (r[i] &gt; i) swap(a[i], a[r[i]]);
    for (int i = 1; i &lt; n; i &lt;&lt;= 1)
    &#123;
        Complex wn(cos(pi / i), f * sin(pi / i));
        for (int j = 0; j &lt; n; j += i &lt;&lt; 1)
        &#123;
            Complex w = 1;
            for (int k = 0; k &lt; i; k++, w *= wn)
            &#123;
                Complex x = a[j + k], y = w * a[j + k + i];
                a[j + k] = x + y, a[j + k + i] = x - y;
            &#125;
        &#125;
    &#125;
&#125;
int c[MAXN], m;
void FFT(Complex *a, Complex *b)
&#123;
    int l = 0;
    for (n = 1, m &lt;&lt;= 1; n &lt; m; n &lt;&lt;= 1) ++l;
    for (int i = 0; i &lt; n; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1));
    DFT(a, 1), DFT(b, 1);
    for (int i = 0; i &lt; n; i++) a[i] *= b[i];
    DFT(a, -1);
    for (int i = 0; i &lt; n; i++) a[i] /= n;
    for (int i = 0; i &lt; m; i++) c[i] = (int)(a[i].real() + 0.5);
&#125;
</code></pre><h5 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h5><pre><code class="c++">const int MAXN = 2e6;
const long long MOD = 998244353;
long long A[MAXN], B[MAXN], N;
long long Inv;
int rev[MAXN];
long long pow_mod(long long a, long long b, long long P) &#123;
  long long ans = 1;
  while (b) &#123;
    if (b &amp; 1) ans = ans * a % P;
    b &gt;&gt;= 1;
    a = a * a % P;
  &#125;
  return ans;
&#125;
void FFt(long long *a, int op) &#123;
  long long w, wn, t;
  for (int i = 0; i &lt; N; i++)
    if (i &lt; rev[i]) swap(a[i], a[rev[i]]);
  for (int k = 2; k &lt;= N; k &lt;&lt;= 1) &#123;
    wn = pow_mod(3, op == 1 ? (MOD - 1) / k : MOD - 1 - (MOD - 1) / k, MOD);
    for (int j = 0; j &lt; N; j += k) &#123;
      w = 1;
      for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = w * wn % MOD) &#123;
        t = a[i + j + (k &gt;&gt; 1)] * w % MOD;
        a[i + j + (k &gt;&gt; 1)] = (a[i + j] - t + MOD) % MOD;
        a[i + j] = (a[i + j] + t) % MOD;
      &#125;
    &#125;
  &#125;
  if (op == -1)
    for (int i = 0; i &lt; N; i++) a[i] = a[i] * Inv % MOD;
&#125;
void FFt(const int *a, const int *b, int *res, int n) &#123;
  N = 1;
  while (N &lt; n) N &lt;&lt;= 1;
  Inv = pow_mod(N, MOD - 2, MOD);
  for (int i = 0; i &lt; N; i++)
    if (i &amp; 1)
      rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);
    else
      rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);
  for (int i = 0; i &lt; N; i++) A[i] = a[i], B[i] = b[i];
  FFt(A, 1), FFt(B, 1);
  for (int i = 0; i &lt; N; i++) A[i] = A[i] * B[i] % MOD;
  FFt(A, -1);
  for (int i = 0; i &lt; N; i++) res[i] = A[i];
&#125;
</code></pre><h5 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h5><pre><code class="c++">long long Sum[MAXN];
int Num[MAXN];
#define lowbit(_) ((_) &amp; (-_))
void add(int x, int c) &#123;
  for (int i = x; i &lt;= cnt; i += lowbit(i)) Sum[i] += c, Num[i]++;
&#125;
long long Query(int x) &#123;
  long long ans = 0;
  for (int i = x; i &gt; 0; i -= lowbit(i))
    ans += Sum[i];
  return ans;
&#125;
int query(int x) &#123;
  int ans = 0;
  for (int i = x; i &gt; 0; i -= lowbit(i))
    ans += Num[i];
  return ans;
&#125;
</code></pre><h5 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h5><pre><code class="c++">const int N = 100005;
int Sum[N &lt;&lt; 2];
#define lch l, m, rt &lt;&lt; 1
#define rch m + 1, r, rt &lt;&lt; 1 | 1
void Pushup(int rt)
&#123;
    Sum[rt] = Sum[rt &lt;&lt; 1] + Sum[rt &lt;&lt; 1 | 1]; 
&#125;
void Update(int x, int c, int l, int r, int rt)
&#123;
    if (l == r)
    &#123;
        Sum[rt] = c;
        return;
    &#125;
    int m = l + r &gt;&gt; 1;
    if (x &lt;= m) Update(x, c, lch);
    else Update(x, c, rch);
    Pushup(rt);
&#125;
void buildtree(int l, int r, int rt)
&#123;
    if (l == r)
    &#123;
        Sum[rt] = 1;
        return;
    &#125;
    int m = l + r &gt;&gt; 1;
    buildtree(lch);
    buildtree(rch);
    Pushup(rt);
&#125;
int find(int w, int l, int r, int rt)
&#123;
    if (l == r)
        return l;
    int m = l + r &gt;&gt; 1;
    if (Sum[rt &lt;&lt; 1] &gt;= w)
        return find(w, lch);
    else
        return find(w - Sum[rt &lt;&lt; 1], rch);
&#125;
int Query(int w, int L, int R, int l, int r, int rt)
&#123;
    if (L == l &amp;&amp; R == r)
    &#123;
        if (Sum[rt] &lt; w)
            return -Sum[rt];
        return find(w, l, r, rt);
    &#125;
    int m = l + r &gt;&gt; 1;
    if (R &lt;= m)
        return Query(w, L, R, lch);
    else if (L &gt; m)
        return Query(w, L, R, rch);
    else
    &#123;
        int s1 = Query(w, L, m, lch);
        if (s1 &gt; 0) return s1;
        int s2 = Query(w + s1, m + 1, R, rch);
        if (s2 &gt; 0) return s2;
        return s1 + s2;
    &#125;    
&#125;
int Query_Sum(int L, int R, int l, int r, int rt)
&#123;
    if (L == l &amp;&amp; R == r)
        return Sum[rt];
    int m = l + r &gt;&gt; 1;
    if (R &lt;= m)
        return Query_Sum(L, R, lch);
    if (L &gt; m)
        return Query_Sum(L, R, rch);
    return Query_Sum(L, m, lch) + Query_Sum(m + 1, R, rch);
&#125;
</code></pre><h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><pre><code class="c++">int find(int x) &#123;
  if (fa[x] != x) fa[x] = find(fa[x]);
  return fa[x];
&#125;
</code></pre><h5 id="ST"><a href="#ST" class="headerlink" title="ST"></a>ST</h5><pre><code class="c++">int Max[(50005 &lt;&lt; 1) + 200][16], Min[(50005 &lt;&lt; 1) + 200][16];

int QueryMax(int l, int r)
&#123;
    if (l &gt; N || r &lt; 0) return -0x3f3f3f3f;
    if (l &lt;= 0) l = 1;
    if (r &gt; N) r = N;
    int k = 0;
    while ((1 &lt;&lt; k) &lt;= (r - l + 1)) k++; k--;
    return max(Max[l][k], Max[r - (1 &lt;&lt; k) + 1][k]);
&#125;

int QueryMin(int l, int r)
&#123;
    if (l &gt; N || r &lt; 0) return 0x3f3f3f3f;
    if (l &lt;= 0) l = 1;
    if (r &gt; N) r = N;
    int k = 0;
    while ((1 &lt;&lt; k) &lt;= (r - l + 1)) k++; k--;
    return min(Min[l][k], Min[r - (1 &lt;&lt; k) + 1][k]);
&#125;
int main () &#123;
    for (int i = 1; i &lt;= 15; i++)
        for (int j = 1; j &lt;= N; j++)
        &#123;
            Max[j][i] = max(Max[j][i - 1], Max[j + (1 &lt;&lt; (i - 1))][i - 1]);
            Min[j][i] = min(Min[j][i - 1], Min[j + (1 &lt;&lt; (i - 1))][i - 1]);
        &#125;
&#125;
</code></pre><h5 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
  
using namespace std;
  
inline int read()
&#123;
    int x=0,f=1;char ch=getchar();
    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125;
    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)&#123;x=x*10+ch-&#39;0&#39;;ch=getchar();&#125;
    return x*f;
&#125;
  
const int INF = 0x3f3f3f3f;
const double alpha = 0.756;
const int MAXN = 5e5 + 5;
  
int now;
  
struct Point
&#123;
    int d[2];
    int &amp;operator[](const int &amp;x)
    &#123;
        return d[x];
    &#125;
    inline bool operator &lt; (const Point &amp;x) const
    &#123;
        return d[now] == x.d[now] ? d[now ^ 1] &lt; x.d[now ^ 1] : d[now] &lt; x.d[now];
    &#125;
&#125;a[MAXN], cur;
  
#define dis(_, __) (\
    int(abs(_[0] - __[0]) + abs(_[1] - __[1]))\
)
  
#define size(_) ((_) ? (_)-&gt;s : 0)
  
struct Node
&#123;
    Node *ch[2];
    Point v;
    int s, d;
    int Max[2], Min[2];
    Node(Point x)
    &#123;
        ch[0] = ch[1] = NULL;
        v = x;
        s = 1, d = now;
        Max[0] = Min[0] = x[0];
        Max[1] = Min[1] = x[1];
    &#125;
    Node()&#123;;&#125;
    inline bool operator &lt; (const Node &amp;x) const
    &#123;
        return v &lt; x.v;
    &#125;
    bool IsBad()
    &#123;
        return ((size(ch[0]) &gt; s * alpha) || (size(ch[1]) &gt; s * alpha));
    &#125;
    void Pushup(Node *x)
    &#123;
        if (!x) return;
        for (int i = 0; i &lt;= 1; i++) Min[i] = min(Min[i], x-&gt;Min[i]);
        for (int i = 0; i &lt;= 1; i++) Max[i] = max(Max[i], x-&gt;Max[i]);
        s += x-&gt;s;
    &#125;
    int min_dis()
    &#123;
        int ans = 0;
        ans += max(Min[0] - cur[0], 0) + max(cur[0] - Max[0], 0);
        ans += max(Min[1] - cur[1], 0) + max(cur[1] - Max[1], 0);
        return ans;
    &#125;
&#125;*root;
  
inline void Build(Node *&amp;rt, int l, int r, int d = 0)
&#123;
    if (l &gt; r) return;
    int mid = l + r &gt;&gt; 1;
    now = d;
    nth_element(a + l, a + mid, a + r + 1);
    rt = new Node(a[mid]);
    Build(rt-&gt;ch[0], l, mid - 1, d ^ 1);
    Build(rt-&gt;ch[1], mid + 1, r, d ^ 1);
    rt-&gt;s = 1;
    rt-&gt;Pushup(rt-&gt;ch[0]);
    rt-&gt;Pushup(rt-&gt;ch[1]);
&#125;
  
Node **res;
  
inline void Insert(Node *&amp;rt)
&#123;
    if (rt == NULL)
    &#123;
        rt = new Node(cur);
        res = NULL;
        return;
    &#125;
    now = rt-&gt;d;
    if (cur &lt; rt-&gt;v) Insert(rt-&gt;ch[0]);
    else Insert(rt-&gt;ch[1]);
    rt-&gt;s = 1;
    rt-&gt;Pushup(rt-&gt;ch[0]);
    rt-&gt;Pushup(rt-&gt;ch[1]);
    if (rt-&gt;IsBad()) res = &amp;rt;
&#125;
  
Node *st[MAXN &lt;&lt; 1];
int top = 0;
  
inline void Travel(Node *&amp;rt)
&#123;
    if (!rt) return;
    Travel(rt-&gt;ch[0]);
    st[++top] = rt;
    Travel(rt-&gt;ch[1]);
&#125;
  
inline int cmp(const Node *x, const Node *y)
&#123;
    return x-&gt;v &lt; y-&gt;v;
&#125;
  
inline Node *Divide(int l, int r, int d)
&#123;
    if (l &gt; r) return NULL;
    int mid = l + r &gt;&gt; 1;
    now = d;
    nth_element(st + l, st + mid, st + r + 1, cmp);
    Node *rt = st[mid];
    rt-&gt;ch[0] = Divide(l, mid - 1, d ^ 1);
    rt-&gt;ch[1] = Divide(mid + 1, r, d ^ 1);
    rt-&gt;s = 1;
    rt-&gt;Max[0] = rt-&gt;Min[0] = rt-&gt;v[0];
    rt-&gt;Max[1] = rt-&gt;Min[1] = rt-&gt;v[1];
    rt-&gt;Pushup(rt-&gt;ch[0]);
    rt-&gt;Pushup(rt-&gt;ch[1]);
&#125;
  
inline void ReBuild(Node *&amp;rt)
&#123;
    top = 0;
    int d = rt-&gt;d;
    Travel(rt);
    rt = Divide(1, top, d);
&#125;
  
inline void Insert(Point x)
&#123;
    cur = x;
    Insert(root);
    if (res != NULL)
        ReBuild(*res);
&#125;
  
int Min_ans;
  
inline void Query(Node *rt)
&#123;
    if (!rt) return;
    // if (rt-&gt;min_dis() &gt; Min_ans) return;
    Min_ans = min(Min_ans, dis(rt-&gt;v, cur));
    int dis_l = rt-&gt;ch[0] ? rt-&gt;ch[0]-&gt;min_dis() : INF;
    int dis_r = rt-&gt;ch[1] ? rt-&gt;ch[1]-&gt;min_dis() : INF;
    if (dis_l &lt; dis_r)
    &#123;
        Query(rt-&gt;ch[0]);
        if (dis_r &lt; Min_ans) Query(rt-&gt;ch[1]);
    &#125;
    else
    &#123;
        Query(rt-&gt;ch[1]);
        if (dis_l &lt; Min_ans) Query(rt-&gt;ch[0]);
    &#125;
&#125;
  
inline int Query(Point x)
&#123;
    cur = x;
    Min_ans = INF;
    Query(root);
    return Min_ans;
&#125;
  
int main()
&#123;
    // freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);
    // freopen(&quot;2.out&quot;, &quot;w&quot;, stdout);
    int n, m;
    n = read(), m = read();
    for (int i = 1; i &lt;= n; i++)
        a[i][0] = read(), a[i][1] = read();
    Build(root, 1, n);
    Point x;
    while (m--)
    &#123;
        int t = read();
        if (t == 1)
        &#123;
            x[0] = read(), x[1] = read();
            Insert(x);
        &#125;
        else
        &#123;
            x[0] = read(), x[1] = read();
            printf (&quot;%d\n&quot;, Query(x));
        &#125;
    &#125;
&#125;
</code></pre><h5 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

inline int read()
&#123;
    int x=0,f=1;char ch=getchar();
    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125;
    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)&#123;x=x*10+ch-&#39;0&#39;;ch=getchar();&#125;
    return x*f;
&#125;

const int MAXN = 10010;

struct Node
&#123;
    Node *f, *ch[2];
    bool IsRoot, Mark;
    Node()
    &#123;
        f = ch[0] = ch[1] = NULL;
        IsRoot = 1, Mark = 0;
    &#125;
&#125;*null, *Q[MAXN];
Node *NewNode()
&#123;
    Node *o = new Node();
    o-&gt;f = o-&gt;ch[0] = o-&gt;ch[1] = null;
    return o;
&#125;
bool son(Node *rt)
&#123;
    return rt-&gt;f-&gt;ch[1] == rt;
&#125;
inline void Pushflip(Node *rt)
&#123;
    if (rt == null) return;
    rt-&gt;Mark ^= 1, swap(rt-&gt;ch[0], rt-&gt;ch[1]);
&#125;
inline void Pushdown(Node *rt)
&#123;
    if (rt-&gt;Mark)
    &#123;
        Pushflip(rt-&gt;ch[0]);
        Pushflip(rt-&gt;ch[1]);
        rt-&gt;Mark = 0;
    &#125;
&#125;
inline void rotate(Node *rt)
&#123;
    if (rt-&gt;IsRoot) return;
    Node *fa = rt-&gt;f, *Grand = fa-&gt;f;
    Pushdown(fa), Pushdown(rt);
    int k = son(rt), kk = son(fa);
    fa-&gt;ch[k] = rt-&gt;ch[k ^ 1];
    if (rt-&gt;ch[k ^ 1] != null) rt-&gt;ch[k ^ 1]-&gt;f = fa;
    rt-&gt;ch[k ^ 1] = fa, fa-&gt;f = rt, rt-&gt;f = Grand;
    if (!fa-&gt;IsRoot) Grand-&gt;ch[kk] = rt;
    else fa-&gt;IsRoot = 0, rt-&gt;IsRoot = 1; 
&#125;
inline void Clear(Node *rt)
&#123;
    if (!rt-&gt;IsRoot) Clear(rt-&gt;f);
    Pushdown(rt);
&#125;

inline void Splay(Node *rt)
&#123;
    for (Clear(rt); !rt-&gt;IsRoot; rotate(rt))
        if (!rt-&gt;f-&gt;IsRoot)
            rotate(son(rt) == son(rt-&gt;f) ? rt-&gt;f : rt);
&#125;

inline void Access(Node *rt)
&#123;
    for (Node *pre = null; rt != null; pre = rt, rt = rt-&gt;f)
    &#123;
        Splay(rt);
        rt-&gt;ch[1]-&gt;IsRoot = 1;
        pre-&gt;IsRoot = 0;
        rt-&gt;ch[1] = pre;
    &#125;
&#125;

inline void MakeRoot(Node *rt)
&#123;
    Access(rt);
    Splay(rt);
    Pushflip(rt);
&#125;

inline void link(Node *a, Node *b)
&#123;
    MakeRoot(a);
    a-&gt;f = b;
&#125;

inline void cut(Node *a, Node *b)
&#123;
    MakeRoot(a);
    Access(b);
    Splay(b);
    Pushdown(b);
    b-&gt;ch[0]-&gt;IsRoot = 1;
    b-&gt;ch[0]-&gt;f = null;
    b-&gt;ch[0] = null;
&#125;

inline Node* find(Node *rt)
&#123;
    if (rt-&gt;ch[0] != null) return find(rt-&gt;ch[0]);
    return rt;
&#125;

inline bool Judge(Node *a, Node *b)
&#123;
    while (a-&gt;f != null) a = a-&gt;f;
    while (b-&gt;f != null) b = b-&gt;f;
    return a == b;
&#125;

int main()
&#123;
    int n = read(), m = read();
    null = new Node();
    null-&gt;ch[0] = null-&gt;ch[1] = null-&gt;f = null, null-&gt;IsRoot = null-&gt;Mark = 0;
    for (int i = 1; i &lt;= n; i++)
        Q[i] = NewNode();
    int a, b;
    char c[10];
    while (m--)
    &#123;
        scanf (&quot;%s&quot;, c);
        if (c[0] == &#39;C&#39;)
        &#123;
            a = read(), b = read();
            link(Q[a], Q[b]);
        &#125;
        else if (c[0] == &#39;Q&#39;)
        &#123;
            a = read(), b = read();
            puts(Judge(Q[a], Q[b]) ? &quot;Yes&quot; : &quot;No&quot;);
        &#125;
        else
        &#123;
            a = read(), b = read();
            cut(Q[a], Q[b]);
        &#125;
    &#125;
&#125;
</code></pre><h5 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h5><pre><code class="c++">#include &lt;bits/stdc++.h&gt;
const int N = 1e6 + 1;
using namespace std;
struct edge &#123;
  int END, next, v;
&#125; v[N * 2];
int first[N], p;
void add(int a, int b, int c) &#123;
  v[p].END = b;
  v[p].v = c;
  v[p].next = first[a];
  first[a] = p++;
&#125;
int n, m, S;
typedef pair&lt;int, int&gt; T;
int dis[N];
int main() &#123;
  scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;S);
    memset (first, -1, sizeof (first));
  for (int i = 1; i &lt;= m; i++) &#123;
    int x, y, z;
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
    add(x, y, z);
  &#125;
  memset(dis, 0x3f, sizeof(dis));
  dis[S] = 0;
  T X;
  X.first = 0, X.second = S;
  priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt; &gt; Q;
  Q.push(X);
  while (!Q.empty()) &#123;
    X = Q.top();
    Q.pop();
    int x = X.second;
    if (dis[x] &lt; X.first) continue;
    for (int i = first[x]; i; i = v[i].next) &#123;
      int y = v[i].END;
      if (dis[y] &gt; dis[x] + v[i].v) &#123;
        dis[y] = dis[x] + v[i].v;
        X.first = dis[y];
        X.second = y;
        Q.push(X);
      &#125;
    &#125;
  &#125;
  for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, dis[i]);
  return 0;
&#125;
</code></pre><h5 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h5><pre><code class="c++">int dis[N];
bool flag[N];
queue&lt;int&gt; q;
bool Spfa(int x)
&#123;
    memset(dis, 0x3f, sizeof (dis));
    memset(flag, 0, sizeof (flag));
    dis[x] = 0;
    flag[x] = 1;
    q.push(x);
    while (!q.empty())
    &#123;
        int k = q.front();
        q.pop();
        flag[k] = 0;
        for (int i = first[k]; i != -1; i = v[i].next)
        &#123;
            if (dis[v[i].END] &gt; dis[k] + v[i].v)
            &#123;
                dis[v[i].END] = dis[k] + v[i].v;
                if (!flag[v[i].END])
                &#123;
                    flag[v[i].END] = 1;
                    q.push(v[i].END);
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre><h5 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAXN = 1e6 * 4;
const int MOD  = 998244353;
const int L = (1 &lt;&lt; 18) + 1;
const int LM = (1 &lt;&lt; 16) + 1;
inline int read()
&#123;
    int x=0,f=1;char ch=getchar();
    while (ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;if(ch==&#39;-&#39;)f=-1;ch=getchar();&#125;
    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)&#123;x=x*10+ch-&#39;0&#39;;ch=getchar();&#125;
    return x*f;
&#125;
int N, Inv, rev[MAXN];
int Sum = 0, n, m;
struct data
&#123;
    int e, f, g, id;
&#125;s[60005];
long long pow_mod(long long a, int b)
&#123;
    long long ans = 1;
    while (b)
    &#123;
        if (b &amp; 1)
            ans = ans * a % MOD;
        b &gt;&gt;= 1;
        a = a * a % MOD;
    &#125;
    return ans;
&#125;
int ans[MAXN], cnt;
void insert(int a, int b, int c, int d, int id)
&#123;
    if (b == 0)
    &#123;
        ans[id] = ((1ll * a * Sum) + (1ll * c * n)) % MOD * pow_mod(d, MOD - 2) % MOD;
        return;
    &#125;
    s[++cnt].f = (1ll * b * c - 1ll * a * d) % MOD;
    b = pow_mod(b, MOD - 2);
    s[cnt].e = 1ll * a * b % MOD, s[cnt].g = 1ll * d * b % MOD;
    b = 1ll * b * b % MOD; s[cnt].f = 1ll * s[cnt].f * b % MOD;
    if (s[cnt].f &lt; 0) s[cnt].f += MOD;
    s[cnt].id = id;
&#125;
void Init(int x)
&#123;
    N = 1;
    while (N &lt; (x &lt;&lt; 1)) N &lt;&lt;= 1;
    Inv = pow_mod(N, MOD - 2);
    for (int i = 1; i &lt; N; i++)
        if (i &amp; 1)
            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);
        else
            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);
&#125;
inline int Calc(int x)
&#123;
    N = 1;
    while (N &lt; (x &lt;&lt; 1)) N &lt;&lt;= 1;
    return N;
&#125;
void FFt(int *a, int op)
&#123;
    int w, wn, t;
    for (int i = 0; i &lt; N; i++)
        if (i &lt; rev[i])
            swap(a[i], a[rev[i]]);
    for (int k = 2; k &lt;= N; k &lt;&lt;= 1)
    &#123;
        wn = pow_mod(3, op == 1 ? (MOD - 1) / k : MOD - 1 - (MOD - 1) / k);
        for (int j = 0; j &lt; N; j += k)
        &#123;
            w = 1;
            for (int i = 0; i &lt; (k &gt;&gt; 1); i++, w = 1ll * w * wn % MOD)
            &#123;
                t = 1ll * a[i + j + (k &gt;&gt; 1)] * w % MOD;
                a[i + j + (k &gt;&gt; 1)] = (a[i + j] - t + MOD) % MOD;
                a[i + j] = (a[i + j] + t) % MOD;
            &#125;
        &#125;
    &#125;
    if (op == -1)
        for (int i = 0; i &lt; N; i++)
            a[i] = 1ll * a[i] * Inv % MOD;
&#125;
int tmp[MAXN], x[MAXN];
void Get_Inv(int *a, int *b, int n)
&#123;
    if (n == 1) return b[0] = pow_mod(a[0], MOD - 2), void();
    Get_Inv(a, b, n + 1 &gt;&gt; 1);
    Init(n);
    for (int i = 0; i &lt; n; i++) tmp[i] = a[i];
    for (int i = n; i &lt; N; i++) tmp[i] = 0;
    FFt(tmp, 1), FFt(b, 1);
    for (int i = 0; i &lt; N; i++) 
        b[i] = 1ll * b[i] * ((2 - 1ll * b[i] * tmp[i] % MOD + MOD) % MOD) % MOD;
    FFt(b, -1);
    for (int i = n; i &lt; N; i++) b[i] = 0;
&#125;
int Get_mod(int *a, int ra, int *b, int rb, int *c)
&#123;
    while (ra &amp;&amp; !a[ra - 1]) --ra;
    while (rb &amp;&amp; !b[rb - 1]) --rb;
    if (ra &lt; rb)
    &#123;
        memcpy (c, a, ra &lt;&lt; 2);
        memset (c + ra, 0, (rb - ra) &lt;&lt; 2);
        return rb;
    &#125;
    static int tmp1[MAXN], tmp2[MAXN];
    int rc = ra - rb + 1;
    int l = Calc(rc);
    for (int i = 0; i &lt; l; i++) tmp1[i] = 0;
    reverse_copy(b, b + rb, tmp1);
    for (int i = 0; i &lt; l; i++) tmp2[i] = 0; 
    Get_Inv(tmp1, tmp2, rc);
    for (int i = rc; i &lt; l; i++) tmp2[i] = 0;
    reverse_copy(a, a + ra, tmp1);
    for (int i = rc; i &lt; l; i++) tmp1[i] = 0;
    Init(rc), FFt(tmp1, 1), FFt(tmp2, 1);
    for (int i = 0; i &lt; N; i++) tmp1[i] = 1ll * tmp1[i] * tmp2[i] % MOD;
    FFt(tmp1, -1); 
    reverse(tmp1, tmp1 + rc); 
    Init(ra);
    for (int i = 0; i &lt; rb; i++) tmp2[i] = b[i];
    for (int i = rb; i &lt; N; i++) tmp2[i] = 0;
    for (int i = rc; i &lt; N; i++) tmp1[i] = 0;
    FFt(tmp1, 1), FFt(tmp2, 1);
    for (int i = 0; i &lt; N; i++) tmp1[i] = 1ll * tmp1[i] * tmp2[i] % MOD;
    FFt(tmp1, -1);
    for (int i = 0; i &lt; rb; i++) c[i] = (a[i] - tmp1[i] + MOD) % MOD;
    for (int i = rb; i &lt; N; i++) c[i] = 0;
    while (rb &amp;&amp; !c[rb - 1]) --rb;
    return rb;
&#125;
int Solve0(int *a, int l, int r)
&#123;
    int ra = r - l + 2;
    if (ra &lt;= 256)
    &#123;
        memset(a, 0, ra &lt;&lt; 2), a[0] = 1;
        for (int i = l; i &lt;= r; i++)
            for (int v = x[i], j = i - l; j != -1; j--)
            &#123;
                a[j + 1] = (a[j + 1] + a[j]) % MOD;
                a[j] = 1ll * a[j] * v % MOD;
            &#125;
        return ra;
    &#125;
    int mid = l + r &gt;&gt; 1;
    int *f1 = a, r1 = Solve0(f1, l, mid);
    int *f2 = a + r1, r2 = Solve0(f2, mid + 1, r);
    N = 1;
    while (N &lt; ra) N &lt;&lt;= 1;
    Inv = pow_mod(N, MOD - 2);
    for (int i = 1; i &lt; N; i++)
        if (i &amp; 1)
            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);
        else
            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);
    static int tmp1[L], tmp2[L];
    memcpy(tmp1, f1, r1 &lt;&lt; 2), memset (tmp1 + r1, 0, (N - r1) &lt;&lt; 2), FFt(tmp1, 1);
    memcpy(tmp2, f2, r2 &lt;&lt; 2), memset (tmp2 + r2, 0, (N - r2) &lt;&lt; 2), FFt(tmp2, 1);
    for (int i = 0; i &lt; N; i++) a[i] = 1ll * tmp1[i] * tmp2[i] % MOD;
    FFt(a, -1);
    return ra;
&#125;
int *p[L];
int sta[MAXN];
int mem[LM &lt;&lt; 4], *head = mem;
inline int Solve1(int id, int l, int r)
&#123;
    int ra = r - l + 2;
    if (ra &lt;= 256)
    &#123;
        int *f = p[id] = head; head += ra;
        memset (f, 0, ra &lt;&lt; 2), 0[f] = 1;
        for (int i = l; i &lt;= r; i++)
            for (int v = (MOD - sta[i]) % MOD, j = i - l; j != -1; j--)
                f[j + 1] = (f[j + 1] + f[j]) % MOD, f[j] = 1ll * f[j] * v % MOD;
        return ra;
    &#125;
    int mid = l + r &gt;&gt; 1;
    int r1 = Solve1(id &lt;&lt; 1, l, mid), *f1 = p[id &lt;&lt; 1];
    int r2 = Solve1(id &lt;&lt; 1 | 1, mid + 1, r), *f2 = p[id &lt;&lt; 1 | 1];
    N = 1;
    while (N &lt; ra) N &lt;&lt;= 1;
    Inv = pow_mod(N, MOD - 2);
    for (int i = 1; i &lt; N; i++)
        if (i &amp; 1)
            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (N &gt;&gt; 1);
        else
            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1);
    static int tmp1[LM], tmp2[LM];
    memcpy(tmp1, f1, r1 &lt;&lt; 2), memset (tmp1 + r1, 0, (N - r1) &lt;&lt; 2), FFt(tmp1, 1);
    memcpy(tmp2, f2, r2 &lt;&lt; 2), memset (tmp2 + r2, 0, (N - r2) &lt;&lt; 2), FFt(tmp2, 1);
    int *f = p[id] = head; head += ra;
    for (int i = 0; i &lt; N; i++) f[i] = 1ll * tmp1[i] * tmp2[i] % MOD;
    FFt(f, -1);
    return ra; 
&#125;
int val0[LM], val[LM];
void Solve2(int id, int *a, int *b, int l, int r, int deg)
&#123;
    int ra = r - l + 2;
    if (deg &lt;= 256)
    &#123;
        int F, G;
        for (int i = l; i &lt;= r; i++)
        &#123;
            F = G = 0;
            int u = sta[i], v = 1;
            for (int j = 0; j &lt;= deg; j++)
            &#123;
                F = (F + 1ll * v * a[j]) % MOD;
                G = (G + 1ll * v * b[j]) % MOD;
                v = 1ll * v * u % MOD;
            &#125;
            val0[i] = F, val[i] = G;
        &#125;
        return;
    &#125;
    int mid = l + r &gt;&gt; 1;
    int r1 = Get_mod(a, deg, p[id], ra, a + deg); a += deg;
    int r2 = Get_mod(b, deg, p[id], ra, b + deg); b += deg;
    ra = min(r1, r2);
    Solve2(id &lt;&lt; 1, a, b, l, mid, ra), Solve2(id &lt;&lt; 1 | 1, a, b, mid + 1, r, ra);
&#125;
int g[MAXN], h[MAXN];
int main()
&#123;
    n = read(), m = read();
    Sum = 0;
    for (int i = 1; i &lt;= n; i++)
        x[i] = read() % MOD, Sum = (Sum + x[i]) % MOD;
    int A = 1, B = 0, C = 0, D = 1;
    for (int i = 1; i &lt;= m; i++)
    &#123;
        if (read() == 1)
        &#123;
            int v = read() % MOD;
            A = (A + 1ll * v * B % MOD) % MOD;
            C = (C + 1ll * v * D % MOD) % MOD;
            insert(A, B, C, D, i);
        &#125;
        else
        &#123;
            swap(A, B);
            swap(C, D);
            insert(A, B, C, D, i);
        &#125;
    &#125;
    if (cnt)
    &#123;
        for (int i = 1; i &lt;= cnt; i++) sta[i] = s[i].g;
        sort(sta + 1, sta + cnt + 1);
        int lenth = unique(sta + 1, sta + cnt + 1) - sta - 1;
        for (int i = 1; i &lt;= cnt; i++)
            s[i].g = lower_bound(sta + 1, sta + lenth + 1, s[i].g) - sta;
        Solve0(g, 1, n);
        for (int i = 1; i &lt;= n; i++) h[i - 1] = 1ll * g[i] * i % MOD;
        Solve1(1, 1, lenth);
        Solve2(1, g, h, 1, lenth, n + 1);
        for (int i = 1; i &lt;= cnt; i++)
            ans[s[i].id] = (1ll * s[i].e * n % MOD + 1ll * s[i].f * val[s[i].g] % MOD * pow_mod(val0[s[i].g], MOD - 2) % MOD) % MOD;
    &#125;
    for (int i = 1; i &lt;= m; i++)
        printf (&quot;%d\n&quot;, ans[i]);
    // while (1);
&#125;
</code></pre><h5 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h5><pre><code class="c++">long long gauss(int n)
&#123;
    long long ans = 1;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            a[i][j] = (a[i][j] + MOD) % MOD;
    for (int i = 1; i &lt;= n; i++)
    &#123;
        for (int j = i + 1; j &lt;= n; j++)
            while (a[j][i])
            &#123;
                int t = a[i][i] / a[j][i];
                for (int k = i; k &lt;= n; k++)
                &#123;
                    a[i][k] = (a[i][k] - a[j][k] * t % MOD + MOD) % MOD;
                    swap(a[i][k], a[j][k]);
                &#125;
                ans = (MOD - ans) % MOD;
            &#125;
        ans = ans * a[i][i] % MOD;
    &#125;
    return ans;
&#125;



void gauss() &#123;
  int im, num = 1;
  for (int k = 1; k &lt;= n; k++, num++) &#123;
    im = k;
    for (int i = k + 1; i &lt;= n; i++) &#123;
      if (fabs(a[i][k]) &gt; fabs(a[im][k])) i = im;
    &#125;
    if (im != k) &#123;
      for (int i = k; i &lt;= n + 1; i++) swap(a[num][i], a[im][i]);
    &#125;
    if (!a[num][k]) &#123;
      num--;
      continue;
    &#125;
    for (int i = num + 1; i &lt;= n; i++) &#123;
      if (!a[num][k]) continue;
      long double t = a[i][k] / a[num][k];
      for (int j = k; j &lt;= n + 1; j++) &#123;
        a[i][j] -= t * a[k][j];
      &#125;
    &#125;
  &#125;
  for (int i = n; i &gt;= 1; i--) &#123;
    for (int j = n; j &gt;= i + 1; j--) &#123;
      a[i][n + 1] -= a[i][j] * x[j];
    &#125;
    x[i] = a[i][n + 1] / a[i][i];
    sum += x[i];
  &#125;
&#125;
</code></pre><h5 id="BSGS-amp-exBSGS"><a href="#BSGS-amp-exBSGS" class="headerlink" title="BSGS&amp;exBSGS"></a>BSGS&amp;exBSGS</h5><pre><code class="c++">int pow_mod(int a, int b, int c)
&#123;
    int ans = 1;
    while (b)
    &#123;
        if (b &amp; 1) ans = ans * a % c;
        b &gt;&gt;= 1;
        a = a * a % c;
    &#125;
    return ans;
&#125;
struct Hash_Table
&#123;
    struct edge
    &#123;
        int next, x, ans;
    &#125;v[100005];
    int first[76545], p;
    int &amp;operator[](int x)
    &#123;
        int H = x % 76543;
        for (int i = first[H]; i != -1; i = v[i].next)
            if (v[i].x == x)
                return v[i].ans;
        v[p].x = x;
        v[p].next = first[H];
        first[H] = p++;
        return v[p - 1].ans = 0;
    &#125;
    bool count(int x)
    &#123;
        int H = x % 76543;
        for (int i = first[H]; i != -1; i = v[i].next)
            if (v[i].x == x)
                return 1;
        return 0;
    &#125;
    void clear()
    &#123;
        memset (first, -1, sizeof (first));
        p = 0;
    &#125;
&#125;Hash;
int gcd(int a, int b)
&#123;
    return b == 0 ? a : gcd(b, a % b);
&#125;
int BSGS(int a, int b, int c, int d)
&#123;
    Hash.clear();
    int m = floor(sqrt(c)) + 1;
    for (int i = 0; i &lt;= m; i++)
    &#123;
        // if (!Hash.count(b)) 
        Hash[b] = i;
        b = b * a % c;
    &#125;
    int s = pow_mod(a, m, c);
    for (int i = 1; i &lt;= m; i++)
    &#123;
        d = d * s % c;
        if (Hash.count(d)) return i * m - Hash[d];
    &#125;
    return -1;
&#125;
int exBSGS(int a, int b, int c)
&#123;
    b %= c;
    int s = 1;
    for (int i = !a; i &lt;= 40; i++)
    &#123;
        if (s == b) return i;
        s = s * a % c;
    &#125;
    int cnt = 0, d = 1;
    for (int i; (i = gcd(a, c)) != 1; cnt++)
    &#123;
        if (b % i) return -1;
        b /= i, c /= i;
        d = d * a / i % c;
    &#125;
    int ret = BSGS(a, b, c, d);
    if (ret == -1) return -1;
    return ret + cnt;
&#125;
</code></pre><h5 id="KMP-amp-EXKMP"><a href="#KMP-amp-EXKMP" class="headerlink" title="KMP&amp;EXKMP"></a>KMP&amp;EXKMP</h5><pre><code class="c++">long long nxt[MAXN], pre[MAXN], extend[MAXN];
char w[MAXN], t[MAXN];
void KMP(char *s, int n) &#123;
  for (int i = 2, k; i &lt;= n; i++) &#123;
    k = nxt[i - 1];
    while (k &amp;&amp; s[i] != s[k + 1]) k = nxt[k];
    if (s[i] == s[k + 1]) nxt[i] = k + 1;
    else nxt[i] = 0;
  &#125;
&#125;
void Get_Extend(char *s, int n) &#123;
  pre[1] = n;
  pre[2] = 1;
  while (s[pre[2]] == s[pre[2] + 1] &amp;&amp; pre[2] + 1 &lt;= n) pre[2]++;
  pre[2]--;
  int P_pos = 2;
  for (int i = 3; i &lt;= n; i++) &#123;
    if (pre[i - P_pos + 1] + i &lt; pre[P_pos] + P_pos) pre[i] = pre[i - P_pos + 1];
    else &#123;
      pre[i] = pre[P_pos] + P_pos - i;
      if (pre[i] &lt; 0) pre[i] = 0;
      while (s[pre[i] + 1] == s[pre[i] + i] &amp;&amp; i + pre[i] &lt;= n) pre[i]++;
      P_pos = i;
    &#125;
  &#125;
&#125;
void Match(char *s, char *t) &#123;
  int m = strlen(s + 1), n = strlen(t);
  Get_Extend(t, n);
  extend[1] = 1;
  while (s[extend[1]] == t[extend[1]] &amp;&amp; extend[1] &lt;= n) extend[1]++;
  extend[1]--;
  int P_pos = 1;
  for (int i = 2; i &lt;= m; i++) &#123;
    if (pre[i - P_pos + 1] + i &lt; extend[P_pos] + P_pos) extend[i] = pre[i - P_pos + 1];
    else &#123;
      extend[i] = P_pos + extend[P_pos] - i;
      if (extend[i] &lt; 0) extend[i] = 0;
      while (t[extend[i] + 1] == s[i + extend[i]] &amp;&amp; i + extend[i] &lt;= m &amp;&amp; extend[i] &lt;= n) extend[i]++;
      P_pos = i;
    &#125;
  &#125;
&#125;
</code></pre><h5 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h5><pre><code class="c++">const int MAXN = 50000;
int prime[MAXN + 2], mu[MAXN + 2], Sum_mu[MAXN + 2], d[MAXN + 2], e[MAXN + 2], cnt;
long long Sum_d[MAXN + 2];
bool isnprime[MAXN + 2];
void Get_d()
&#123;
    mu[1] = 1, d[1] = 1, isnprime[1] = 1;
    for (int i = 2; i &lt;= MAXN; i++)
    &#123;
        if (!isnprime[i])
        &#123;
            prime[++cnt] = i;
            e[i] = 1;
            d[i] = 2;
            mu[i] = -1;
        &#125;
        for (int j = 1; j &lt;= cnt; j++)
        &#123;
            if (i * prime[j] &gt; MAXN) break;
            isnprime[i * prime[j]] = 1;
            if (i % prime[j] == 0)
            &#123;
                mu[i * prime[j]] = 0;
                d[i * prime[j]] = d[i] / (e[i] + 1) * (e[i] + 2);
                e[i * prime[j]] = e[i] + 1; 
                break;
            &#125;
            mu[i * prime[j]] = -mu[i];
            d[i * prime[j]] = d[i] * 2;
            e[i * prime[j]] = 1;
        &#125;
    &#125;
    for (int i = 1; i &lt;= MAXN; i++)
    &#123;
        Sum_mu[i] = Sum_mu[i - 1] + mu[i];
        Sum_d[i] = Sum_d[i - 1] + d[i];
    &#125;
&#125;
</code></pre><h5 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h5><pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
struct Hash_Table &#123;
  struct edge &#123;
    long long x;
    int ans, next;
  &#125;v[100005];
  int first[76545], p;
  Hash_Table() &#123;
    memset (first, -1, sizeof (first));
    p = 0;
  &#125;
  int &amp;operator[] (const long long &amp;x) &#123;
    int H = x % 76543;
    for (int i = first[H]; i != -1; i = v[i].next) &#123;
      if (v[i].x == x)
        return v[i].ans;
    &#125;
    v[p].x= x;
    v[p].next = first[H];
    first[H] = p++;
    return v[p - 1].ans = 0;
  &#125;
  bool count(const long long &amp;x) &#123;
    int H = x % 76543;
    for (int i = first[H]; i != -1; i = v[i].next) &#123;
      if (v[i].x == x)
        return 1;
    &#125;
    return 0;
  &#125;
&#125;mp;
const int MAXN = 1e6;
bool isnprime[MAXN + 5];
int mu[MAXN + 5], prime[MAXN + 5], cnt;
void Get_Prime() &#123;
  mu[1] = 1, isnprime[1] = 1;
  for (int i = 2; i &lt;= MAXN; i++) &#123;
    if (!isnprime[i]) prime[++cnt] = i, mu[i] = -1;
    for (int j = 1; j &lt;= cnt; j++) &#123;
      if (i * prime[j] &gt; MAXN) break;
      isnprime[i * prime[j]] = 1;
      if (i % prime[j] == 0) &#123;
        mu[i * prime[j]] = 0;
        break;
      &#125; else &#123;
        mu[i * prime[j]] = -mu[i];
      &#125;
    &#125;
  &#125;
  for (int i = 1; i &lt;= MAXN; i++)
    mu[i] += mu[i - 1];
&#125;
int Mu(long long x) &#123;
  if (x &lt;= MAXN) return mu[x];
  if (mp.count(x)) return mp[x];
  int &amp;ans = mp[x] = 1;
  long long nxt = 1;
  for (long long i = 2; i &lt;= x; i = nxt + 1) &#123;
    nxt = x / (x / i);
    ans -= (nxt - i + 1) * Mu(x / i);
  &#125;
  return ans;
&#125;
int main() &#123;
  Get_Prime();
  long long a, b;
  cin &gt;&gt; a &gt;&gt; b;
  cout &lt;&lt; Mu(b) - Mu(a - 1) &lt;&lt; endl;
&#125;
</code></pre><h5 id="Miller-Robin"><a href="#Miller-Robin" class="headerlink" title="Miller_Robin"></a>Miller_Robin</h5><pre><code class="c++">long long tmp[100];
int tot;
int prime[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;;
long long mul(long long a, long long b, long long z) &#123;
  return (a * b - (long long)(((long double)a * b + 0.5) / (long double)z) * z + z) % z;
&#125;
long long pow_mod(long long a, long long b, long long p) &#123;
  a %= p;
  long long ans = 1;
  while (b) &#123;
    if (b &amp; 1) ans = mul(ans, a, p);
    b &gt;&gt;= 1;
    a = mul(a, a, p);
  &#125;
  return ans;
&#125;
bool Miller_Rabin(long long x) &#123;
  if (x == 1) return 0;
  for (int i = 0; i &lt;= 9; ++i) &#123;
    if (x == prime[i]) return 1;
    if (x % prime[i] == 0) return 0;
  &#125;
  long long y = x - 1;
  int k = 0;
  for (; !(y &amp; 1); y &gt;&gt;= 1) k++;
  for (int i = 0; i &lt; 10; ++i) &#123;
    long long z = rand() % (x - 1) + 1;
    long long c = pow_mod(z, y, x), d;
    for (int j = 0; j &lt; k; ++j, c = d)
      if ((d = mul(c, c, x)) == 1 &amp;&amp; c != 1 &amp;&amp; c != x - 1)
        return 0;
    if (d != 1) return 0;
  &#125;
  return 1;
&#125;
long long Pollard_Rho(long long x, int y) &#123;
  long long i = 1, k = 2, c = rand() % (x - 1) + 1;
  long long d = c;
  while (1) &#123;
    i++;
    c = (mul(c, c, x) + y) % x;
    long long g = __gcd((d - c + x) % x, x);
    if (g != 1 &amp;&amp; g != x) return g;
    if (c == d) return x;
    if (i == k) d = c, k &lt;&lt;= 1;
  &#125;
&#125;
void Divide(long long x, int c) &#123;
  if (x == 1) return;
  if (Miller_Rabin(x)) return tmp[++tot] = x, void();
  long long z = x, tp = c;
  while (z &gt;= x) z = Pollard_Rho(z, c--);
  Divide(z, tp), Divide(x / z, tp);
&#125;
</code></pre></div><div class="additional-content-after-post"><strong>本文作者 : NekoMio</strong><br><strong><a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</strong><br><strong>本文链接 : <a href="https://www.nekomio.com/2019/07/31/templates/" target="_blank">https://www.nekomio.com/2019/07/31/templates/</a></strong></div></article><div id="share_container"><div id="share" data-initialized="true"><a class="no-pjax icon-wechat" tooltip="分享到微信"><button class="btn btn-icon btn-success"><span class="btn-inner--icon"><i class="fa fa-weixin"></i></span></button> </a><a target="_blank" class="no-pjax icon-douban" tooltip="分享到豆瓣"><button class="btn btn-icon btn-primary" style="background:#209261;border:none">豆</button> </a><a target="_blank" class="no-pjax icon-qq" tooltip="分享到 QQ"><button class="btn btn-icon btn-primary" style="background:#2196f3;border:none"><span class="btn-inner--icon"><i class="fa fa-qq"></i></span></button> </a><a target="_blank" class="no-pjax icon-qzone" tooltip="分享到 QQ 空间"><button class="btn btn-icon btn-primary" style="background:#ffc107;border:none"><span class="btn-inner--icon"><i class="fa fa-star"></i></span></button> </a><a target="_blank" class="no-pjax icon-weibo" tooltip="分享到微博"><button class="btn btn-icon btn-warning"><span class="btn-inner--icon"><i class="fa fa-weibo"></i></span></button> </a><a target="_blank" class="no-pjax icon-facebook" tooltip="分享到 Facebook"><button class="btn btn-icon btn-primary" style="background:#283593;border:none"><span class="btn-inner--icon"><i class="fa fa-facebook"></i></span></button> </a><a target="_blank" class="no-pjax icon-twitter" tooltip="分享到 Twitter"><button class="btn btn-icon btn-primary" style="background:#03a9f4;border:none"><span class="btn-inner--icon"><i class="fa fa-twitter"></i></span></button> </a><a target="_blank" class="no-pjax icon-telegram" href="https://telegram.me/share/url?url=https://www.nekomio.com/2019/07/31/templates/&text=模板库" tooltip="分享到 Telegram"><button class="btn btn-icon btn-primary" style="background:#42a5f5;border:none"><span class="btn-inner--icon"><i class="fa fa-telegram"></i></span></button> </a><a target="_blank" class="no-pjax icon-copy-link" id="share_copy_link" tooltip="复制链接"><button class="btn btn-icon btn-default"><span class="btn-inner--icon"><i class="fa fa-link"></i></span></button></a></div><button id="share_show" class="btn btn-icon btn-primary" tooltip="分享"><span class="btn-inner--icon"><i class="fa fa-share"></i></span></button></div><script>socialShare("#share",{title:"模板库",description:"\n算法 (AG)\n网络流 (NF)\n网络流线性规划\n上下界网络流\n最小割\n费用流\n\n\nEdmond-...",wechatQrcodeTitle:"分享到微信",wechatQrcodeHelper:"微信扫描二维码",source:"https://www.nekomio.com/2019/07/31/templates/"}),$("#share_show")[0].onclick=function(){$("#share_container").addClass("opened")},$("#share_copy_link")[0].onclick=function(){var o=document.createElement("input");document.body.appendChild(o),o.setAttribute("value",window.location.href),o.setAttribute("readonly","readonly"),o.setAttribute("style","opacity: 0;mouse-events:none;"),o.select(),document.execCommand("copy")?iziToast.show({title:"链接已复制",message:"链接已复制到剪贴板",class:"shadow",position:"topRight",backgroundColor:"#2dce89",titleColor:"#ffffff",messageColor:"#ffffff",iconColor:"#ffffff",progressBarColor:"#ffffff",icon:"fa fa-check",timeout:5e3}):iziToast.show({title:"复制失败",message:"请手动复制链接",class:"shadow",position:"topRight",backgroundColor:"#f5365c",titleColor:"#ffffff",messageColor:"#ffffff",iconColor:"#ffffff",progressBarColor:"#ffffff",icon:"fa fa-close",timeout:5e3}),document.body.removeChild(o)}</script><div id="post_comment" class="card shadow-sm"><div id="waline" style="margin:10px"></div><script>function loadWaline(){argonConfig.waline=Waline.init({el:"#waline",locale:{placeholder:"评论经过人工审核后可见(Comment are visible after manual review)"},path:window.location.pathname,pageSize:"10",wordLimit:250,lang:"zh-cn",serverURL:"https://comment.nekomio.com",emoji:["//unpkg.com/@waline/emojis@1.1.0/weibo","//unpkg.com/@waline/emojis@1.1.0/bilibili"]})}function destroyWaline(){argonConfig.waline&&(argonConfig.waline.destroy(),argonConfig.waline=null)}</script></div><div class="post-navigation card shadow-sm"><div class="post-navigation-item post-navigation-pre"><span class="page-navigation-extra-text"><i class="fa fa-arrow-circle-o-left" aria-hidden="true"></i>上一篇</span><a href="/2019/08/11/154/" rel="prev"> Min25 筛法的原理与应用</a></div><div class="post-navigation-item post-navigation-next"><span class="page-navigation-extra-text">下一篇 <i class="fa fa-arrow-circle-o-right" aria-hidden="true"></i></span><a href="/2019/06/17/153/" rel="next"> 小米手环3 NFC 体验</a></div></div><footer id="footer" class="site-footer card shadow-sm border-0"><a target="_blank" href="https://beian.miit.gov.cn/" rel="nofollow noopener noreferrer noopener">京ICP备19044785号-1</a><div>「<a target="_blank" rel="noopener" href="https://www.cloudflare.com/">Cloudflare Pages</a> 提供网站托管服务」</div><div>Theme <a target="_blank" rel="noopener" href="https://github.com/solstice23/hexo-theme-argon"><strong>Argon</strong></a> | Powered by Hexo</div><span id="busuanzi_container_site_uv">本站访客数 <span id="busuanzi_value_site_uv"></span> 人次</span></footer></main></div></div><script src="/argontheme.js"></script><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/KaTeX/0.16.0/katex.min.css"><script src="//cdn.bootcdn.net/ajax/libs/KaTeX/0.16.0/katex.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/KaTeX/0.16.0/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})})</script><script>var argonEnableCodeHighlight=!0</script><link rel="stylesheet" href="/assets/vendor/highlight/styles/vs2015.css"><noscript><style>article img.lazyload[src^="data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPg"]{display:none}.comment-item-text .comment-sticker.lazyload{display:none}</style></noscript></body></html>